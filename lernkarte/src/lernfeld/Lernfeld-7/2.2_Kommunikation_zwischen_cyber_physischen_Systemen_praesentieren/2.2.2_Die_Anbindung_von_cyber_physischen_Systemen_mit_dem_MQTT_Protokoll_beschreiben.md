# 📡 2.2.2 Die Anbindung von cyber-physischen Systemen mit dem MQTT-Protokoll beschreiben [Seite: 104]

**MQTT** ist ein schlankes **Messaging-Protokoll** für das **Internet of Things**, das speziell für geringe Bandbreite und knappe Energie Budgets konzipiert wurde. Es wurde 2014 als **OASIS-Standard** anerkannt; **MQTT 5** brachte 2019 erweiterte, IoT-relevante Funktionen. 

## 🧠 Einordnung & Zweck

* **Leichtgewichtiges Binärprotokoll** für **M2M-Kommunikation**; nahezu **Echtzeit** möglich.
* Unterstützt **Text-, Binär- und Objektnachrichten**; **kein integrierter Sicherheitsmechanismus** – daher Absicherung auf Transport-/Broker-Ebene erforderlich. 

## 🏗️ Architektur: Publish/Subscribe mit Broker

* **Broker** entkoppelt **Publisher** und **Subscriber**: Sender übermittelt an den Broker, der an alle interessierten Empfänger weiterverteilt (**ereignisorientiert**, im Gegensatz zu typischen Client/Server-Abfragen).
* **Clients** verbinden sich als **Publisher** oder **Subscriber** (oder beides) mit dem Broker.

## 🧩 Zentrale Begriffe & Komponenten

* **MQTT-Broker:** nativ (speziell für MQTT) oder via Konnektor; **Mosquitto** eignet sich z. B. für **Raspberry Pi**/**Mikrocontroller**.
* **MQTT-Client:** beliebiges Gerät mit **MQTT-Bibliothek**, das sich über ein Netzwerk mit dem Broker verbindet. 

## 🏷️ Topics (Themen) sauber strukturieren

* **Topics** sind hierarchisch (mit „/“) und **groß/kleinschreibungssensitiv**; **$** am Anfang ist für Broker-Statistiken reserviert.
* **Gestaltungsregeln:** keinen führenden **„/“**, **keine Leer-/Sonderzeichen**, **kurz halten** (Topic wird in jeder Nachricht mitgesendet).

## 🧭 Topic-Wildcards

* **„+“** ersetzt **eine** Ebene (einstufige Wildcard).
* **„#“** ersetzt **alle folgenden** Ebenen (mehrstufige Wildcard, nur **am Ende**); Wildcards gelten nur zum **Abonnieren**, nicht zum Publizieren. 

## 📨 Quality of Service (QoS)

* **QoS 1 – at least once:** Zustellung mit **PUBACK** bestätigt; mögliche **Duplikate**, die Empfänger behandeln müssen.
* **QoS 2 – exactly once:** Vierfach-Handshake (**PUBREC → PUBREL → PUBCOMP**) garantiert **genau einmal**; benötigt mehr Bandbreite/Latenz. 

## 🔗 Zustands- & Sitzungsmanagement

* **Keep Alive:** Client gibt Timeout vor; **PINGREQ/PINGRESP** prüft Verbindung und hält sie aktiv. 
* **Last Will and Testament (LWT):** Broker sendet im Fehlerfall vordefinierte **„letzte“ Nachricht** des Publishers an dessen Subscriber. 
* **Nachrichtenpersistenz:** Sender kann vorhalten und bei **QoS 1** bis zum **PUBACK** erneut senden (Duplikatgefahr). 
* **MQTT over WebSockets:** erlaubt direkte **Browser-Anbindung** an den Broker. 

## ⚙️ Eigenschaften für die CPS-Anbindung

* **Performance:** sehr kleine Header, effizient für **viele, kleine Sensornachrichten**; größere Payloads ggf. über HTTP mit Komprimierung günstiger.
* **Skalierbarkeit:** viele Geräte/Sensoren über **einen Server**.
* **Sicherheit:** MQTT selbst nur **Benutzer/Passwort**; **TLS/SSL-Verschlüsselung**, **Zertifikate** und **ACLs** auf Broker-/Transportschicht empfohlen.

## 🛠️ Praxisnahe Kopplungsschritte (überblicksartig)

* **Broker auswählen & bereitstellen** (z. B. **Mosquitto**).
* **Clients konfigurieren** (Broker-Adresse, **Topic**-Struktur, **QoS**, **Keep Alive/LWT**).
* **Sicherheit aktivieren** (**TLS/SSL**, Zugangsdaten, **ACLs**).

---

**Kernidee:** **MQTT** bindet **CPS** zuverlässig und ressourcenschonend an – via **Broker-zentriertem Publish/Subscribe**, klarer **Topic-Organisation**, passenden **QoS-Stufen** und Transport-/Broker-seitiger **Sicherheit**. 
