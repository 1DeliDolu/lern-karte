# ğŸ“¡ 2.2.2 Die Anbindung von cyber-physischen Systemen mit dem MQTT-Protokoll beschreiben [Seite: 104]

**MQTT** ist ein schlankes **Messaging-Protokoll** fÃ¼r das **Internet of Things**, das speziell fÃ¼r geringe Bandbreite und knappe Energie Budgets konzipiert wurde. Es wurde 2014 als **OASIS-Standard** anerkannt; **MQTT 5** brachte 2019 erweiterte, IoT-relevante Funktionen. 

## ğŸ§  Einordnung & Zweck

* **Leichtgewichtiges BinÃ¤rprotokoll** fÃ¼r **M2M-Kommunikation**; nahezu **Echtzeit** mÃ¶glich.
* UnterstÃ¼tzt **Text-, BinÃ¤r- und Objektnachrichten**; **kein integrierter Sicherheitsmechanismus** â€“ daher Absicherung auf Transport-/Broker-Ebene erforderlich. 

## ğŸ—ï¸ Architektur: Publish/Subscribe mit Broker

* **Broker** entkoppelt **Publisher** und **Subscriber**: Sender Ã¼bermittelt an den Broker, der an alle interessierten EmpfÃ¤nger weiterverteilt (**ereignisorientiert**, im Gegensatz zu typischen Client/Server-Abfragen).
* **Clients** verbinden sich als **Publisher** oder **Subscriber** (oder beides) mit dem Broker.

## ğŸ§© Zentrale Begriffe & Komponenten

* **MQTT-Broker:** nativ (speziell fÃ¼r MQTT) oder via Konnektor; **Mosquitto** eignet sich z. B. fÃ¼r **Raspberry Pi**/**Mikrocontroller**.
* **MQTT-Client:** beliebiges GerÃ¤t mit **MQTT-Bibliothek**, das sich Ã¼ber ein Netzwerk mit dem Broker verbindet. 

## ğŸ·ï¸ Topics (Themen) sauber strukturieren

* **Topics** sind hierarchisch (mit â€/â€œ) und **groÃŸ/kleinschreibungssensitiv**; **$** am Anfang ist fÃ¼r Broker-Statistiken reserviert.
* **Gestaltungsregeln:** keinen fÃ¼hrenden **â€/â€œ**, **keine Leer-/Sonderzeichen**, **kurz halten** (Topic wird in jeder Nachricht mitgesendet).

## ğŸ§­ Topic-Wildcards

* **â€+â€œ** ersetzt **eine** Ebene (einstufige Wildcard).
* **â€#â€œ** ersetzt **alle folgenden** Ebenen (mehrstufige Wildcard, nur **am Ende**); Wildcards gelten nur zum **Abonnieren**, nicht zum Publizieren. 

## ğŸ“¨ Quality of Service (QoS)

* **QoS 1 â€“ at least once:** Zustellung mit **PUBACK** bestÃ¤tigt; mÃ¶gliche **Duplikate**, die EmpfÃ¤nger behandeln mÃ¼ssen.
* **QoS 2 â€“ exactly once:** Vierfach-Handshake (**PUBREC â†’ PUBREL â†’ PUBCOMP**) garantiert **genau einmal**; benÃ¶tigt mehr Bandbreite/Latenz. 

## ğŸ”— Zustands- & Sitzungsmanagement

* **Keep Alive:** Client gibt Timeout vor; **PINGREQ/PINGRESP** prÃ¼ft Verbindung und hÃ¤lt sie aktiv. 
* **Last Will and Testament (LWT):** Broker sendet im Fehlerfall vordefinierte **â€letzteâ€œ Nachricht** des Publishers an dessen Subscriber. 
* **Nachrichtenpersistenz:** Sender kann vorhalten und bei **QoS 1** bis zum **PUBACK** erneut senden (Duplikatgefahr). 
* **MQTT over WebSockets:** erlaubt direkte **Browser-Anbindung** an den Broker. 

## âš™ï¸ Eigenschaften fÃ¼r die CPS-Anbindung

* **Performance:** sehr kleine Header, effizient fÃ¼r **viele, kleine Sensornachrichten**; grÃ¶ÃŸere Payloads ggf. Ã¼ber HTTP mit Komprimierung gÃ¼nstiger.
* **Skalierbarkeit:** viele GerÃ¤te/Sensoren Ã¼ber **einen Server**.
* **Sicherheit:** MQTT selbst nur **Benutzer/Passwort**; **TLS/SSL-VerschlÃ¼sselung**, **Zertifikate** und **ACLs** auf Broker-/Transportschicht empfohlen.

## ğŸ› ï¸ Praxisnahe Kopplungsschritte (Ã¼berblicksartig)

* **Broker auswÃ¤hlen & bereitstellen** (z. B. **Mosquitto**).
* **Clients konfigurieren** (Broker-Adresse, **Topic**-Struktur, **QoS**, **Keep Alive/LWT**).
* **Sicherheit aktivieren** (**TLS/SSL**, Zugangsdaten, **ACLs**).

---

**Kernidee:** **MQTT** bindet **CPS** zuverlÃ¤ssig und ressourcenschonend an â€“ via **Broker-zentriertem Publish/Subscribe**, klarer **Topic-Organisation**, passenden **QoS-Stufen** und Transport-/Broker-seitiger **Sicherheit**. 
