# 3.4.3 Ein Deep-Learning-Verfahren mit TensorFlow umsetzen [Seite: 250–252]

**Ziel und Kontext**
Mit **TensorFlow** und **Keras** wird exemplarisch gezeigt, wie sich ein Deep-Learning-Verfahren in **Python** implementieren lässt. **TensorFlow** ist weit verbreitet und funktionsreich; **Keras** ist darin integriert und vereinfacht die Nutzung. Die Wahl fällt auf TensorFlow/Keras wegen Open-Source-Lizenz, guter Python-Integration und breiter Community-Unterstützung.

## Zentrale Begriffe

* **Tensor**: mehrdimensionale **Matrizen** als Ein-/Zwischenausgaben im Netz und Transportform zwischen **Schichten**. 

## Beispielrahmen (Aufgabe)

* **Klimamonitoring** in einer Bootsreparaturhalle: Ein Feuchtigkeitssensor liefert Werte **0–100**; **≥ 85** gilt als **kritisch**. Aufgabe: Binäre **Klassifikation** „kritisch / nicht kritisch“. 

## Vorgehen: TensorFlow/Keras schrittweise

1. **Eingabe & Schwelle definieren**
   `schwelle = 85`; Eingabe als `tf.constant(..., shape=(1,))`. 
2. **Modellaufbau (Sequential)**
   `tf.keras.Sequential()` mit einer **Dense**-Schicht: `units=1`, `input_dim=1`, **Aktivierungsfunktion**: **sigmoid**. 
3. **Kompilieren**
   **Loss**: `binary_crossentropy`; **Optimierer**: `RMSprop(learning_rate=1e-4)`; **Metrik**: `acc`. Optional: **Modellgrafik** via `tf.keras.utils.plot_model(...)`. 
4. **Erste Inferenz (ohne Training)**
   `model.predict(eingabe)` liefert nur eine rohe Schätzung—ohne Aussagekraft. 
5. **Trainingsdaten erzeugen**
   Zufallswerte `65–100` (1000 Stichproben); **Label**: `1` wenn `x ≥ 85`, sonst `0`. 
6. **Training**
   `model.fit(x=training, y=ergebnis, epochs=10000, verbose=0)`. Langes Training, um die **Entscheidungsschwelle** zu lernen. 
7. **Tests**
   Vorhersagen um die Schwelle prüfen (`84`, `85`, `86`) und runden (`round(...)`). 
8. **Evaluierung**
   `model.evaluate(training, ergebnis)`—im Beispiel **acc = 1.0000**, **loss ≈ 0.2694** auf den Trainingsdaten. 

## Ergebnisinterpretation und Hinweise

* Das Netz lernt die binäre **Entscheidungsregel** (Schwellwert **85**) und klassifiziert korrekt. Die Evaluation bezieht sich auf **Trainingsdaten**—für den Produktionseinsatz wären **Validierung/Test** mit unabhängigen Daten erforderlich. 

## Merksätze

* **TensorFlow + Keras**: leistungsstark und **benutzerfreundlich** für schnelle Prototypen. 
* **Minimalarchitektur** (ein **Neuron** mit **sigmoid**) genügt für einfache **Schwellenklassifikation**. 
* **Loss/Metrik/Optimierer** passend zur **Aufgabe** wählen (hier: binäre Klassifikation → `binary_crossentropy`, `acc`, **RMSprop**). 
* **Training** und **Evaluation** klar trennen; Ergebnisse ohne Training sind **nicht** aussagekräftig. 
