# 1.4.2 Benutzerschnittstellen in Python realisieren [Seite: 51]

Ziel des Abschnitts ist die Umsetzung grafischer Benutzerschnittstellen (**GUI**) in **Python** auf Basis vorhandener **Wireframes** und **Mockups**. Aufgrund der Vielfalt der Möglichkeiten konzentriert sich der Abschnitt auf grundlegende **GUI-Elemente** und typische Werkzeuge/Workflows; weiterführendes Wissen entsteht durch das eigenständige Entwickeln mehrerer Oberflächen. 

## Grundidee der GUI-Programmierung in Python

* **Tkinter (Tk)** ist Teil der **Standardbibliothek** und ermöglicht die Erstellung einfacher GUIs. Für Tkinter existiert (Stand April 2022) kein ausgereifter **GUI-Designer**; Oberflächen werden i. d. R. per Hand programmiert.
* Über **Bindings** (z. B. **PyQt**) lassen sich leistungsfähigere Oberflächen realisieren; zugehörige Werkzeuge wie der **Qt-Designer** können mitgenutzt werden. 

## Grundelemente: Zuordnung Tkinter ↔ PyQt (Auswahl)

* **Fenster**: `Frame` ↔ `QWidget`
* **Tabs**: `Notebook/Frame` ↔ `QTabWidget/QWidget`
* **Menü**: `Menu` ↔ `QMenuBar`
* **Textbox**: `Entry` ↔ `QLineEdit`
* **Label**: `Label` ↔ `QLabel`
* **Button**: `Button` ↔ `QPushButton`
* **Radiobutton**: `Radiobutton` ↔ `QRadioButton`
* **Checkbox**: `Checkbutton` ↔ `QCheckBox`
* **Listbox**: `Listbox` ↔ `QListWidget`
* **Combobox**: `Combobox` ↔ `QComboBox`
* **Bild**: `Photoimage` ↔ `QPixmap`
* **Schieberegler**: `Scale` ↔ `QSlider`
  Diese Tabelle dient der schnellen Orientierung beim Wechsel zwischen Tkinter und PyQt. 

## Werkzeugkette mit PyQt6 und Qt-Designer (in PyCharm)

* **PyQt6 installieren**: In **PyCharm** neues Projekt → **Settings → Project Interpreter** → Paket **PyQt6** suchen und installieren. 
* **Qt-Designer & `pyuic` einbinden**: Als **externe Tools** hinterlegen.

  * **Qt-Designer**: `Program = …\designer.exe`, `Working directory = $ProjectFileDir$`.
  * **pyuic6**: `Program = …\pyuic6.exe`, `Arguments = $FileName$ -o $FileNameWithoutExtension$.py`, `Working directory = $ProjectFileDir$`.
    So lassen sich `.ui`-Dateien komfortabel in **Python-Module** umwandeln.

## Typischer Ablauf mit PyQt

1. **Oberfläche entwerfen** (Qt-Designer, Drag-and-Drop der **Widgets**).
2. **In Code umwandeln** (`pyuic6` erzeugt die Klassen-Struktur).
3. **Hauptprogramm** erstellen:

   * GUI-Klasse importieren und ableiten (`QWidget`, erzeugte UI-Klasse).
   * **Events/Signale** anbinden (z. B. Button-Klicks).
   * **Fenster anzeigen** mit `.show()`; Programmlauf via **`QApplication`** und `app.exec()`. 

## Events, Signale und Styles

* **Zustände abfragen**: z. B. `QRadioButton.isChecked()`.
* **Stile setzen**: z. B. Farben per `setStyleSheet("background-color: …")`.
* **Slider-Werte** auslesen und anzeigen (`QSlider` → Label setzen).
* **Signals/Slots** können im Qt-Designer vorbereitet werden; Funktionskörper werden im Code implementiert.

## Beispiel 1: Grundelemente-Fenster

* Oberfläche mit **Label**, **Textbox**, **Buttons**, **Radio-/Checkboxen**, **Slider**.
* **Beispielmethoden**:

  * Text aus `QLineEdit` lesen und in **Dialog** (`QMessageBox`) anzeigen.
  * **Hintergrundfarbe** eines Labels per `setStyleSheet` umschalten.
  * **Sichtbarkeit** von Textblöcken über Checkbox-Status steuern. 

## Beispiel 2: Dialog „Liegeplatzdaten“

* Mit Qt-Designer gestalteter **Dialog** (mehrere Eingabefelder, Statusauswahl).
* **Events** über „**Signale und Slots**“ zugewiesen; Eventfunktionen werden im Hauptprogramm ergänzt.
* Generierter Designer-Code plus kompaktes **Main-Programm** zeigen den Aufbau wiederverwendbarer Dialoge.

## Beispiel 3: Sprachausgabe (Barrierefreiheit)

* **Ziel**: Texteingabe vorlesen lassen (de/en).
* **Bibliotheken**: **gTTS** (Google Text-to-Speech) und **playsound**; Installation via `pip install gTTS playsound`.
* **Vorgehen**: Text aus `QTextEdit` lesen → mit **gTTS** zu **MP3** generieren → mit **playsound** abspielen → Datei optional löschen.
* **GUI**: Sprachauswahl per **QRadioButton**, Steuerung über **Buttons**.

## Ergebnis & Nutzen

* Der Abschnitt vermittelt eine **praxisnahe Pipeline**: von der **GUI-Skizze** (Wireframe/Mockup) über **Designer-gestützte Oberflächen** bis zur **Event-Logik** und **Erweiterungen** (z. B. **TTS**).
* Kernkompetenzen sind die **sichere Auswahl und Kombination** von **Widgets**, das **Signal/Slot-Konzept**, die **Einbindung externer Tools** und das **saubere Strukturieren** von **Hauptprogramm** und **UI-Klasse**.
