# 1.2.2 Architekturmuster unterscheiden [Seite: 24]

**Architekturmuster** sind wiederverwendbare Lösungsvorlagen für den grundlegenden Aufbau eines Softwaresystems. Sie stehen über **Entwurfsmustern** (für Subsysteme/Komponenten) und **Implementierungsmustern**/**Idiomen** (sprachspezifische Lösungen) und legen v. a. Organisation und Interaktion der Hauptkomponenten fest. 

<!--D:\lern-karte\lernkarte\public\lernfeld10a\1_2_2\image1.png-->

![Architekturmuster im Überblick](/lernfeld10a/1_2_2/image1.png)

## Einordnung der Musterarten

* **Architekturmuster**: gestalten die Systemarchitektur und beeinflussen Subsysteme; sprachunabhängig.
* **Entwurfsmuster**: für Komponenten/Subsysteme; geringerer Einfluss auf das Gesamtsystem; sprachunabhängig.
* **Implementierungsmuster/Idiome**: lösen sprachspezifische Detailprobleme; sprachabhängig. 

## Kategorien von Architekturmustern

* **Mud-to-Structure**: ordnen viele Komponenten (z. B. **Schichtenarchitektur**, **Blackboard**).
* **Verteilte Systeme**: Nutzung von Diensten/Ressourcen im Netzwerk (z. B. **Client-Server-Architektur**, **Peer-to-Peer**).
* **Interaktive Systeme**: Fokus Mensch–System-Interaktion (z. B. **Model-View-Controller (MVC)**, **Model-View-Presenter (MVP)**).
* **Adaptive Systeme**: Erweiterbarkeit/Anpassungsfähigkeit (z. B. **Reflection**, **Dependency Injection**). 

## Beispielmuster (ausführlich betrachtet)

### (1) **Drei-Schichten-Architektur**

Spezialfall der **Schichtenarchitektur** mit drei klar getrennten Verantwortlichkeiten:

* **Präsentationsschicht** (Client/Front End): Darstellung, Eingaben, **Benutzerschnittstelle**.
* **Logikschicht** (Application/Middle/Enterprise Tier): **Anwendungslogik** und Verarbeitung.
* **Datenhaltungsschicht** (Data/Back End): **Persistenz**, Speichern/Laden (typisch: Datenbank). 

![Drei-Schichten-Architektur](/lernfeld10a/1_2_2/image2.png)

**Vorteile:**

* Geringere Abhängigkeiten zwischen Komponenten.
* **Definierte Schnittstellen** zwischen den Schichten.
* Änderungen betreffen meist nur die eigene Schicht.
* Austausch einzelner Schichten möglich.

**Nachteil:**

* Potentiell geringere **Ausführungsgeschwindigkeit** durch Weiterleitung/Transformation über mehrere Schichten. 

### (2) **Client-Server-Architektur**

Wird als zentrales Muster der **verteilten Systeme** hervorgehoben und im Abschnitt beispielhaft mitbetrachtet. (Hinweis: Im Material wird sie als Beispiel benannt; die detaillierte Ausführung konzentriert sich hier vor allem auf die Drei-Schichten-Architektur und MVC.) 

![Client-Server-Architektur](/lernfeld10a/1_2_2/image3.png)

### (3) **Model-View-Controller (MVC)**

* **Model**: verwaltet **Daten** und **Geschäftsregeln**.
* **View**: **Präsentation** der Model-Daten.
* **Controller**: nimmt **Eingaben/Events** entgegen, steuert Model und View.
  In der Praxis melden Controller Ereignisse ans Model; das Model informiert die View über Änderungen. 

![Model-View-Controller (MVC)](/lernfeld10a/1_2_2/image4.png)

**Vorteile:**

* **Klare Trennung der Verantwortlichkeiten** → bessere **Wartbarkeit/Testbarkeit**.
* **Parallelisierbare Entwicklung** von View/Controller vs. Model.

**Nachteile:**

* **Mehr Abstimmungsaufwand/Komplexität** durch zusätzliche Rollen/Kommunikation. 

## Kernaussage

Der Abschnitt zeigt, wie **Architekturmuster** die Struktur großer Systeme systematisch formen und dabei – je nach Kategorie – Organisation, Verteilung, Interaktion oder Anpassbarkeit adressieren. Exemplarisch werden die **Drei-Schichten-Architektur** (klare Trennung, saubere Schnittstellen) und **MVC** (strikte Rollenaufteilung zwischen Daten, Darstellung, Steuerung) vertieft, während die **Client-Server-Architektur** als prägendes Muster verteilter Anwendungen eingeordnet wird.

---
[Nächste Thema](../1.3-Benutzerschnittstellen-funktionsgerecht-und-ergonomisch-konzipieren/1.3_Benutzerschnittstellen_funktionsgerecht_und_ergonomisch_konzipieren.md)
