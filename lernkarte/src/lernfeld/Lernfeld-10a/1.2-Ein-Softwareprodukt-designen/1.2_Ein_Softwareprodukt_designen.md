# 1.2 Ein Softwareprodukt designen [Seite: 20]

Das **Softwaredesign** definiert Architektur, Komponenten, **Schnittstellen**, **Datenstrukturen** und **Algorithmen** eines Systems. Es startet, sobald grundlegende Anforderungen vorliegen, und wird – je nach Vorgehensmodell – einmalig (z. B. Wasserfall) oder iterativ (z. B. agil) durchlaufen. Ergebnisse werden fortlaufend verfeinert und optimiert. 

## Entwurfsebenen

* **Architekturentwurf**: Legt den grundlegenden Aufbau des Systems fest; identifiziert Subsysteme/Module und deren Beziehungen. Ergebnis ist die **Softwarearchitektur** als „Bauplan“. Qualitätseffekte u. a. auf Wartbarkeit, Effizienz, Zuverlässigkeit.
* **Detailentwurf**: Präzisiert den Aufbau jedes Moduls (Struktur, **Schnittstellen**, Datenstrukturen, Algorithmen); Ergebnis ist der **Modulentwurf**. 

## 1.2.1 Benutzerschnittstellen im Kontext der Softwarearchitektur

### Begriff und Ziel

* **Softwarearchitektur**: Beschreibung der Komponenten und ihrer Verbindungen; Sorgfalt nötig, da spätere Änderungen teuer sind. 

### Merkmale guter Architektur

* **Modularität**, **Entkopplung**, **Abstraktion**, **Einfachheit**, **Vollständigkeit**, **Parallelität** – ermöglichen skalierbares, wartbares Design und effizientere Ausführung. 

### Bausteine und Schnittstellen

* **Modul**: Funktional geschlossene Einheit mit klar spezifizierten **Schnittstellen**. 
* **Schnittstelle**: Verbindung zwischen Systemen zur Kommunikation/Übertragung; Unterscheidung in interne (zwischen Modulen) und externe. Externe umfassen **Daten-**, **Hardware-**, **Software-** und **Benutzerschnittstellen** (z. B. CLI, **GUI**). 
* **Benutzerschnittstelle**: Nimmt Eingaben auf, leitet sie zur Verarbeitung weiter und liefert Ergebnisse an Nutzer zurück. 

## 1.2.2 Architekturmuster unterscheiden

### Einordnung der Muster

* Ebenen: **Architekturmuster** (Systemorganisation), Entwurfsmuster (Subsysteme/Komponenten), Implementierungsmuster/Idiome (sprachenabhängig). 
* Kategorien von Architekturmuster: **Mud-to-Structure** (z. B. Schichten, Blackboard), **Verteilte Systeme** (z. B. **Client-Server**), **Interaktive Systeme** (z. B. **MVC**, MVP), **Adaptive Systeme** (z. B. Reflection, Dependency Injection). 

### Beispielmuster (ausgeführt im Abschnitt)

#### **Drei-Schichten-Architektur**

* **Präsentation** (GUI), **Logik**, **Datenhaltung** – klare Aufgabentrennung mit definierten Schnittstellen. 
* **Vorteile**: Weniger Abhängigkeiten, definierte Schnittstellen, Änderungen meist lokal, leichter Austausch einer Schicht.
  **Nachteile**: Potentielle geringere Ausführungsgeschwindigkeit durch Weiterleitungen/Transformationen. 

#### **Client-Server-Architektur**

* **Server** bietet Dienste, **Clients** nutzen sie; häufige Kombination mit Drei-Schichten durch Verteilung auf unterschiedliche Systeme (Client-, Applikations-, Datenbank-Server).
  **Effekt**: Bessere **Skalierbarkeit**; Risiko zentraler Ausfälle erfordert Hardware-Gegenmaßnahmen. 

#### **Model-View-Controller (MVC)**

* **View (V)**: Darstellung & Erfassung von Interaktionen.
  **Controller (C)**: Anwendungslogik; wertet Interaktionen aus, ändert Daten.
  **Model (M)**: Daten & Struktur; informiert View über Änderungen. 
* **Vorteile**: Mehrere/tauschbare **Views**, leicht erweiterbar, synchronisierte Ansichten, unterstützt agile Entwicklung.
  **Nachteil**: Erhöhte **Komplexität** der Anwendung. 

---

### Kernaussage für die Benutzerschnittstelle

Die UI ist Teil der Architekturbetrachtung (externe **Benutzerschnittstelle**) und profitiert direkt von modularen, entkoppelten Strukturen sowie passenden Architekturmustern (z. B. **Drei-Schichten**, **MVC**), die klare Verantwortlichkeiten und austauschbare Darstellungsebenen ermöglichen.

---

## [Nächstes Thema](./1.2.1_Benutzerschnittstellen_in_den_Kontext_der_Softwarearchitektur_einordnen.md)