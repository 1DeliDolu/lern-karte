# üêç 5.7.6 Eine SQLite-Datenbank mit Python ansprechen [Seite: 605]

In diesem Abschnitt wird erl√§utert, wie man mithilfe von **Python** auf eine **SQLite-Datenbank** zugreift.
Ziel ist es, **Datenbanken zu erstellen**, **SQL-Anweisungen auszuf√ºhren** und **Ergebnisse zu verarbeiten** ‚Äì alles direkt aus einem Python-Programm heraus.

SQLite ist ein **leichtgewichtiges relationales Datenbanksystem**, das **bereits in Python integriert** ist und **keinen separaten Server** ben√∂tigt. Es speichert alle Daten **in einer einzigen Datei** und unterst√ºtzt **alle wichtigen SQL-Befehle**.

---

## ‚öôÔ∏è Grundlagen zu SQLite

| Merkmal            | Beschreibung                                                                  |
| ------------------ | ----------------------------------------------------------------------------- |
| **Datenmodell**    | Relationales Modell (Tabellen, Beziehungen, Schl√ºssel).                       |
| **Struktur**       | Eine Datenbank = eine Datei (z. B. `personenverwaltung.db`).                  |
| **Vorteil**        | Keine Installation n√∂tig, schnell, ideal f√ºr kleine bis mittlere Anwendungen. |
| **Einsatzgebiete** | Eingebettete Systeme, mobile Apps, Prototyping, Desktop-Anwendungen.          |

---

## üß© (1) Verbindung herstellen, SQL-Anweisungen ausf√ºhren und schlie√üen

Um mit SQLite in Python zu arbeiten, wird das Modul **`sqlite3`** verwendet.

### Schritte im √úberblick:

1. **Modul importieren**

   ```python
   import sqlite3
   ```

2. **Verbindung zur Datenbank herstellen**

   ```python
   connection = sqlite3.connect("personenverwaltung.db")
   ```

   * Wenn die Datei nicht existiert, wird sie automatisch erstellt.
   * R√ºckgabewert: ein **Connection-Objekt**.

3. **Cursor erzeugen**

   ```python
   cursor = connection.cursor()
   ```

   * Der Cursor ist das ‚ÄûSteuerelement‚Äú f√ºr SQL-Anweisungen.
   * Mit ihm werden Befehle an die Datenbank gesendet.

4. **SQL-Anweisung ausf√ºhren**

   ```python
   sql_anweisung = """
   CREATE TABLE Person (
       PersonID INTEGER PRIMARY KEY AUTOINCREMENT,
       Name TEXT NOT NULL,
       Vorname TEXT,
       Groesse FLOAT,
       Gewicht FLOAT,
       Geburtsdatum DATE,
       OrtID INT
   )
   """
   cursor.execute(sql_anweisung)
   ```

   * Die SQL-Anweisung wird √ºber **`execute()`** ausgef√ºhrt.
   * Enth√§lt die Anweisung DML-Befehle (z. B. `INSERT`, `UPDATE`, `DELETE`), m√ºssen √Ñnderungen best√§tigt werden.

5. **√Ñnderungen speichern**

   ```python
   connection.commit()
   ```

   * Schreibt alle √Ñnderungen dauerhaft in die Datenbank.

6. **Verbindung schlie√üen**

   ```python
   connection.close()
   ```

   * Beendet die Sitzung und gibt die Datei frei.

---

## üß∞ Beispiel: Anlegen einer Tabelle mit Fehlerbehandlung

```python
import sqlite3
import os.path

def personentabelle_anlegen():
    try:
        if os.path.exists("personenverwaltung.db"):
            connection = sqlite3.connect("personenverwaltung.db")
            cursor = connection.cursor()

            sql_anweisung = """
            CREATE TABLE Person (
                PersonID INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT NOT NULL,
                Vorname TEXT,
                Groesse REAL,
                Gewicht REAL,
                Geburtsdatum DATE,
                OrtID INT
            )
            """
            cursor.execute(sql_anweisung)
            connection.commit()
    except Exception as e:
        print("Fehler beim Erstellen der Tabelle:", e.args[0])
    finally:
        connection.close()
```

**Erl√§uterungen:**

* `try / except / finally` wird genutzt, um **Ausnahmen (Exceptions)** abzufangen.
* In **`finally`** wird die Verbindung immer geschlossen ‚Äì selbst bei Fehlern.
* `commit()` ist n√∂tig, um √Ñnderungen zu √ºbernehmen.

---

## üßÆ (2) Datens√§tze einf√ºgen, √§ndern und l√∂schen

### Beispiel: Datensatz einf√ºgen

```python
sql_anweisung = """
INSERT INTO Person (Name, Vorname, Groesse, Gewicht, Geburtsdatum, OrtID)
VALUES ('M√ºller', 'Klaus', 1.80, 80.0, '1990-04-21', 1)
"""
cursor.execute(sql_anweisung)
connection.commit()
```

* SQL wird als **String** √ºbergeben.
* √Ñnderungen werden erst durch **`commit()`** gespeichert.

---

## üîç (3) Daten abfragen und in der Konsole anzeigen

Nach einer Abfrage stehen die Ergebnisse im **Cursor-Objekt** zur Verf√ºgung.

```python
sql_anweisung = "SELECT * FROM Person"
cursor.execute(sql_anweisung)

for datensatz in cursor:
    print(
        str(datensatz[0]),  # PersonID
        str(datensatz[1]),  # Name
        str(datensatz[2]),  # Vorname
        str(datensatz[3]),  # Groesse
        str(datensatz[4]),  # Gewicht
        str(datensatz[5]),  # Geburtsdatum
        str(datensatz[6])   # OrtID
    )
```

**Erl√§uterungen:**

* Jeder Datensatz ist ein **Tupel** (mehrere Werte).
* Zugriff √ºber **Indexposition** `[0], [1], [2], ‚Ä¶`.
* Die Ergebnisse k√∂nnen formatiert oder weiterverarbeitet werden.

---

## üß† Zusammenfassung ‚Äì Arbeitsschritte mit SQLite in Python

| Schritt | Python-Code / Methode                          | Beschreibung            |
| ------- | ---------------------------------------------- | ----------------------- |
| 1       | `import sqlite3`                               | Modul laden             |
| 2       | `connection = sqlite3.connect("datenbank.db")` | Verbindung aufbauen     |
| 3       | `cursor = connection.cursor()`                 | Cursor-Objekt erstellen |
| 4       | `cursor.execute(SQL)`                          | SQL-Anweisung ausf√ºhren |
| 5       | `connection.commit()`                          | √Ñnderungen speichern    |
| 6       | `connection.close()`                           | Verbindung beenden      |

---

## ‚úÖ Zentrale Erkenntnisse und Lernziele

* **SQLite** nutzt das **relationale Datenmodell** und ist vollst√§ndig in Python integriert.
* Das Modul **`sqlite3`** erm√∂glicht direkte SQL-Befehle aus Python heraus.
* **Cursors** sind f√ºr die Ausf√ºhrung und Iteration √ºber Datens√§tze erforderlich.
* √Ñnderungen (Insert, Update, Delete) m√ºssen mit **`commit()`** best√§tigt werden.
* Mit **`try / except / finally`** lassen sich Datenbankaktionen sicher und fehlerfrei ausf√ºhren.
* So k√∂nnen Lernende eine **eigene Datenbankanwendung in Python entwickeln** ‚Äì von der Erstellung bis zur Abfrage.

---

## [N√§chstes Thema](../5.8_Software_testen_und_dokumentieren/)