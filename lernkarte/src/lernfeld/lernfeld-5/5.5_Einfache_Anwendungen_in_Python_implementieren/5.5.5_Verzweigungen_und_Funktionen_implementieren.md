# üîÄ 5.5.5 Verzweigungen und Funktionen implementieren [Seite: 544]

In diesem Abschnitt lernen Sie, wie Programme durch **Verzweigungen (Kontrollstrukturen)** und **Funktionen** gesteuert und strukturiert werden. Dadurch k√∂nnen Programme **dynamisch auf Bedingungen reagieren** und **modular aufgebaut** werden.

---

## üí° Ziel

Die Lernenden sollen verstehen,

* wie Entscheidungen im Programmablauf durch **Verzweigungen (if / elif / else)** getroffen werden,
* wie man Bedingungen mit **relationalen** und **booleschen Operatoren** formuliert,
* und wie man **Funktionen** definiert, nutzt und wiederverwendet.

---

## ‚öôÔ∏è (1) Verzweigungen (Selektionen)

Verzweigungen erm√∂glichen unterschiedliche Programmabl√§ufe in Abh√§ngigkeit von **Bedingungen**.

### üîπ Grundprinzip:

> Eine Bedingung wird gepr√ºft ‚Äì ist sie **wahr (True)**, wird ein Anweisungsblock ausgef√ºhrt; andernfalls ein anderer.

---

### üî∏ Einseitige Verzweigung

Nur **eine Anweisung** wird ausgef√ºhrt, wenn die Bedingung erf√ºllt ist.

**Struktogramm:**

```
Bedingung?
‚îÇ
‚îú‚îÄ Ja ‚Üí Anweisungsblock
‚îî‚îÄ Nein ‚Üí (nichts)
```

**Python-Syntax:**

```python
if zahl > 0:
    print("Die Zahl ist gr√∂√üer als 0")
```

---

### üî∏ Zweiseitige Verzweigung

Zwei Bl√∂cke ‚Äì einer f√ºr **True**, einer f√ºr **False**.

**Struktogramm:**

```
Bedingung?
‚îÇ
‚îú‚îÄ Ja ‚Üí Anweisungsblock 1
‚îî‚îÄ Nein ‚Üí Anweisungsblock 2
```

**Python-Syntax:**

```python
zahl = float(input("Geben Sie eine Zahl ein: "))

if zahl >= 10.0 and zahl <= 20.0:
    print("Die Zahl liegt im Bereich von 10 bis 20")
else:
    print("Die Zahl liegt au√üerhalb dieses Bereichs")
```

---

### üî∏ Mehrfache Verzweigung (Fallunterscheidung)

Mit mehreren Bedingungen kann eine Variable auf verschiedene Werte gepr√ºft werden.
In Python wird das mit **`elif`** umgesetzt (anstelle von ‚Äûswitch-case‚Äú in anderen Sprachen).

**Struktogramm:**

```
Bedingung 1?
‚îÇ
‚îú‚îÄ Ja ‚Üí Block 1
‚îú‚îÄ Nein, Bedingung 2?
‚îÇ   ‚îú‚îÄ Ja ‚Üí Block 2
‚îÇ   ‚îú‚îÄ Nein, Bedingung 3?
‚îÇ   ‚îî‚îÄ ...
‚îî‚îÄ Standardfall (else)
```

**Python-Syntax:**

```python
auswahl = int(input("Geben Sie eine ganze Zahl ein: "))

if auswahl == 1:
    print("Es wurde eine 1 eingegeben.")
elif auswahl == 2:
    print("Es wurde eine 2 eingegeben.")
elif auswahl == 3:
    print("Es wurde eine 3 eingegeben.")
else:
    print("Es wurde keine 1, 2 oder 3 eingegeben.")
```

---

### üßä Beispiel: Temperaturbewertung

**Aufgabe:**
Das Programm soll pr√ºfen, ob eine berechnete Durchschnittstemperatur **√ºber**, **unter** oder **gleich** dem langj√§hrigen Mittel liegt.

**Algorithmus:**

1. Eingabe von drei Temperaturen
2. Berechnung des Durchschnitts
3. Vergleich mit dem festgelegten Mittelwert (18,23 ¬∞C)

**Python-Programm:**

```python
try:
    langjaehriges_mittel = 18.23
    print("Berechnung der Durchschnittstemperatur\n")

    t1 = float(input("1. Temperatur: "))
    t2 = float(input("2. Temperatur: "))
    t3 = float(input("3. Temperatur: "))

    durchschnitt = (t1 + t2 + t3) / 3
    print("Durchschnittstemperatur:", durchschnitt, "¬∞C")

    if durchschnitt > langjaehriges_mittel:
        print("Die Temperatur liegt √ºber dem langj√§hrigen Mittel.")
    elif durchschnitt == langjaehriges_mittel:
        print("Die Temperatur entspricht dem langj√§hrigen Mittel.")
    else:
        print("Die Temperatur liegt unter dem langj√§hrigen Mittel.")

except Exception as e:
    print("Fehler:", e)
```

---

## üîç (2) Relationale und Boolesche Operatoren

Diese Operatoren werden genutzt, um **Bedingungen** zu formulieren.

### Relationale Operatoren

| Operator | Bedeutung      | Beispiel  |
| -------- | -------------- | --------- |
| `==`     | Gleichheit     | `x == 10` |
| `!=`     | Ungleichheit   | `x != 10` |
| `<`      | Kleiner als    | `x < 10`  |
| `>`      | Gr√∂√üer als     | `x > 10`  |
| `<=`     | Kleiner gleich | `x <= 10` |
| `>=`     | Gr√∂√üer gleich  | `x >= 10` |

### Boolesche (logische) Operatoren

| Operator | Bedeutung        | Beispiel            |
| -------- | ---------------- | ------------------- |
| `and`    | UND-Verkn√ºpfung  | `x > 0 and x < 10`  |
| `or`     | ODER-Verkn√ºpfung | `x == 5 or x == 10` |
| `not`    | Negation         | `not x == 10`       |

### Wahrheitstabelle

| x     | y     | `x and y` | `x or y` | `not x` |
| ----- | ----- | --------- | -------- | ------- |
| True  | True  | True      | True     | False   |
| True  | False | False     | True     | False   |
| False | True  | False     | True     | True    |
| False | False | False     | False    | True    |

---

## üß© (3) Funktionen

Eine **Funktion** ist ein **Teilprogramm**, das einen bestimmten Auftrag erf√ºllt.
Sie verbessert die **Struktur, √úbersichtlichkeit und Wiederverwendbarkeit** von Code.

### Vorteile:

* Erh√∂hung der **Lesbarkeit** und **Wartbarkeit**
* **Redundanzvermeidung** (Code mehrfach nutzbar)
* **K√ºrzere und klarere Programme**
* Bessere **Fehlerisolierung**

---

### üß± Aufbau einer Funktion

```python
def funktionsname(parameterliste):
    # Funktionsrumpf
    Anweisung(en)
    return R√ºckgabewert
```

* `def` = Schl√ºsselwort zur Funktionsdefinition
* `parameterliste` = optionale √úbergabeparameter
* `return` = (optional) gibt einen Wert zur√ºck
* Alle Anweisungen im Funktionsrumpf m√ºssen **einger√ºckt** sein.

---

### Typen von Funktionen

| Funktionstyp                  | Beispiel                        | Beschreibung        |
| ----------------------------- | ------------------------------- | ------------------- |
| Ohne Parameter, ohne R√ºckgabe | `def hallo(): print("Hi!")`     | f√ºhrt Code aus      |
| Mit Parameter, ohne R√ºckgabe  | `def drucke(name): print(name)` | verarbeitet Eingabe |
| Ohne Parameter, mit R√ºckgabe  | `def gib_pi(): return 3.1415`   | liefert Wert zur√ºck |
| Mit Parameter, mit R√ºckgabe   | `def addiere(a,b): return a+b`  | berechnet Ergebnis  |

---

### üîß Beispiel: Temperaturvergleich mit Funktion

```python
# Funktion zum Vergleich der Temperatur
def vergleiche_temperatur(temp):
    langjaehriges_mittel = 18.23
    if temp > langjaehriges_mittel:
        return "Temperatur liegt √ºber dem langj√§hrigen Mittel"
    elif temp == langjaehriges_mittel:
        return "Temperatur entspricht dem langj√§hrigen Mittel"
    else:
        return "Temperatur liegt unter dem langj√§hrigen Mittel"

# Hauptprogramm
def main():
    try:
        t1 = float(input("1. Temperatur: "))
        t2 = float(input("2. Temperatur: "))
        t3 = float(input("3. Temperatur: "))
        durchschnitt = (t1 + t2 + t3) / 3
        print("Durchschnitt:", durchschnitt)
        print(vergleiche_temperatur(durchschnitt))
    except Exception as e:
        print("Fehler:", e)

main()
```

---

## üîÅ (4) Rekursive Funktionen

Eine **rekursive Funktion** ruft **sich selbst** auf.
Sie wird h√§ufig f√ºr mathematische Berechnungen (z. B. Fakult√§t) verwendet.

**Beispiel:**

```python
def fakultaet(n):
    if n < 1:
        return 1
    else:
        return fakultaet(n - 1) * n

print(fakultaet(4))  # Ausgabe: 24
```

‚ö†Ô∏è **Achtung:** Jede Rekursion muss ein **Ende** haben, sonst f√ºhrt sie zu einem Absturz.

---

## ‚öñÔ∏è (5) Weitere Beispielaufgabe

**Aufgabe:** Programm zur Ausgabe der Gewichtskategorie anhand des BMI.

| BMI             | Kategorie     |
| --------------- | ------------- |
| < 18.5          | Untergewicht  |
| 18.5 ‚â§ BMI < 25 | Normalgewicht |
| 25 ‚â§ BMI < 30   | √úbergewicht   |
| ‚â• 30            | Adipositas    |

**Python-Programm:**

```python
def ermittle_gewichtskategorie():
    try:
        bmi = float(input("Bitte geben Sie Ihren BMI ein: "))
        if bmi < 18.5:
            print("Kategorie: Untergewicht")
        elif bmi < 25:
            print("Kategorie: Normalgewicht")
        elif bmi < 30:
            print("Kategorie: √úbergewicht")
        else:
            print("Kategorie: Adipositas")
    except Exception as e:
        print("Fehler:", e)

ermittle_gewichtskategorie()
```

---

## üß† Zusammenfassung der wichtigsten Konzepte

| **Begriff**                | **Bedeutung**                                           |
| -------------------------- | ------------------------------------------------------- |
| **Verzweigung**            | Entscheidung im Programmablauf mit `if`, `elif`, `else` |
| **Relationale Operatoren** | Vergleichsoperatoren wie `==`, `<`, `>=`                |
| **Boolesche Operatoren**   | Logische Verkn√ºpfungen: `and`, `or`, `not`              |
| **Funktion**               | Wiederverwendbarer Codeblock mit `def`                  |
| **Parameter**              | Eingabewerte einer Funktion                             |
| **R√ºckgabewert**           | Ergebnis einer Funktion mit `return`                    |
| **Rekursion**              | Funktion ruft sich selbst auf                           |

---

‚úÖ **Fazit:**
Mit **Verzweigungen** kann der Programmfluss gezielt gesteuert werden, w√§hrend **Funktionen** f√ºr Ordnung, Wiederverwendbarkeit und Modularit√§t im Quellcode sorgen. Diese Techniken bilden die Grundlage f√ºr die **strukturierte und objektorientierte Programmierung** in Python.


---

## [ Thema](./5.5.6_Schleifen_und_Listen_implementieren.md)