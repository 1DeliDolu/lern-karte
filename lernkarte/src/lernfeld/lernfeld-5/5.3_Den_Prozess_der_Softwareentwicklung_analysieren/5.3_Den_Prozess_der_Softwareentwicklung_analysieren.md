# üß≠ 5.3 Den Prozess der Softwareentwicklung analysieren [Seite: 489]

Der Abschnitt stellt den **Softwareentwicklungsprozess** als langfristigen, nicht linear, sondern h√§ufig **spiralf√∂rmig** verlaufenden Projektprozess dar. Er behandelt die **Prozessphasen** nach IEEE 12207, die **Projektmanagement-Aufgaben**, zentrale **Vorgehensmodelle** (klassisch vs. agil) sowie **Programmiersprachen**, **Frameworks** und **Entwicklungswerkzeuge**. 

| Begriff                            | Definition                                                                                                                                                          |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Prozess**                        | Gesamtheit aller aufeinander einwirkenden Vorg√§nge innerhalb eines Systems.                                                                                         |
| **Projektmanagement**              | Planung, √úberwachung, Steuerung und Abschluss eines Projekts inkl. Ziele, Organisation, Termin-/Ressourcen-/Kostenplanung, Rollen, Kommunikation, Controlling u.a.  |
| **Programmiersprache / Quelltext** | Formale Sprache (DIN 44300) zum Formulieren von Verarbeitungsanweisungen; menschenlesbar als **Quelltext**.                                                         |
| **Programmierparadigma**           | Grundkonzept einer Sprache (z. B. **imperativ**, **objektorientiert**, **deklarativ**).                                                                             |
| **Framework**                      | Wiederverwendbares **Programmierger√ºst** (Application/Domain/Test/Web) zur Reduktion von Routinearbeit.                                                             |
| **IDE**                            | **Integrierte Entwicklungsumgebung**: Editor, Compiler/Interpreter, Debugger, Profiler, Projekt-/Versionsverwaltung unter einer Oberfl√§che.                         |
| **Compiler**                       | √úbersetzt Quelltext **vor** der Laufzeit in Maschinencode (maschinenabh√§ngig).                                                                                      |
| **Interpreter**                    | √úbersetzt Quelltext **zur Laufzeit** schrittweise (plattformunabh√§ngig, i.d.R. langsamer).                                                                          |

## üß© 5.3.1 Die Prozessphasen beschreiben

**Grundlage:** **Softwarelebenszyklus** mit mehreren, in Auspr√§gung und Zeitpunkt variierenden Phasen. 

1. **Anforderungsanalyse und Spezifikation**
   Erfassen von W√ºnschen/Vorgaben, Ist-Zustand, Gesch√§ftsprozessen und Daten; **Lasten-**/**Pflichtenheft**, **Aufwandsabsch√§tzung**. 
2. **Design (Entwurf)**
   Modellbasierter Entwurf (z. B. **UML-Klassendiagramme**, **Struktogramme**), **Datenmodell** und **Datenbanksystem** festlegen, **Schnittstellen** planen, **Testen vorplanen**. 
3. **Umsetzung (Implementierung)**
   Programmierung in gew√§hlter Sprache; flie√üender √úbergang zum Test. 
4. **Testen**
   Verifikation der Anforderungen √ºber **Modul-, Integrations-, System-, Akzeptanztests**. 
5. **Dokumentation**
   Sammlung/Erstellung von **Lasten-/Pflichtenheft**, **Modellen**, **Testprotokollen**, **Bedienungs-/Schulungsunterlagen**. 
6. **Auslieferung**
   Bereitstellung, Installation, Konfiguration beim Auftraggeber/Anwender. 
7. **Wartung und Support**
   Fehlerbehebung, Effizienzsteigerung, Anpassung an **neue Anforderungen**. 

## üóÇÔ∏è 5.3.2 Software im Rahmen eines Projektes entwickeln

**Softwareprojekte** sind typischerweise **einmalig**, zeitlich befristet und neuartig; **Projektmanagement** ist erfolgskritisch. Kernaufgaben u. a.: Ziele abstimmen, Organisation gestalten, Leistung/Termine/Ressourcen/Kosten planen, **AKV-Verteilung**, **Risikoabsch√§tzung**, **Teambildung**, **Kommunikation**, **Controlling**, **Budgettreue**, Besprechungen, Projektabschluss. 

**Erfolgs-/Risikofaktoren** (Auswahl):

* **Erfolg:** klare Ziele, pr√§zise Pl√§ne & Kontrolle, passende Organisation/Kultur, geeignetes Team, optimale Kommunikationsbedingungen.
* **Risiko:** schlechte Kommunikation, mangelhafte Planung, Detail√ºberblick fehlt, unpassende Tools, fehlendes Risikomanagement, Scope-√Ñnderungen. 

## üèóÔ∏è 5.3.3 Vorgehensmodelle unterscheiden

**Klassisch**: **Wasserfall**, **Spiralmodell**, **V-Modell**, **RUP**.
**Agil**: **Serum**, **DevOps-Ansatz**, **XP**, **Kanban**. Agil = h√∂here **Flexibilit√§t**, enge Verzahnung von **Entwicklung** und **Ausf√ºhrung**. 

### (1) Wasserfallmodell

Lineare Phasenabfolge mit Startpunkten, **Meilensteinen**, Endpunkten; umfassende **Dokumentation**.
**+** pr√§zise Anforderungen, klare Phasentrennung, plan-/kalkulierbar, gute Dokumentation.
**‚Äì** geringe Anpassungsf√§higkeit, Auftraggeber wenig eingebunden, Fehler oft sp√§t sichtbar; komplexe Vorhaben schwer strikt zu phasen. 

### (2) Spiralmodell

**Iterativ** zur **Risikominimierung**: (1) Ziele/Rahmen, (2) Alternativen & **Risikoreduktion**, (3) **Entwicklung & Verifikation/Validierung/Tests**, (4) **Auswertung & Zyklusplanung**.
**+** hohe Flexibilit√§t, zyklusweise Planung/Budgetierung, integrierte QS.
**‚Äì** schwer zu parallelisieren, schwierige Risikobewertung, hoher Managementaufwand. 

### (3) V-Modell (inkl. V-Modell XT)

Sequenziell wie Wasserfall, jedoch **Entwicklungs-** und **zugeh√∂rige Testphasen** spiegelbildlich (**Unit/Integration/System/Akzeptanz**). Starker Fokus auf **Qualit√§tssicherung** und **Dokumentation**; verbreitet v. a. im **√∂ffentlichen Sektor**.
**+** bessere Kommunikation, Risiko- und Kostenreduktion, Qualit√§t/Informationssicherheit, geeignet f√ºr **gro√üe** Projekte.
**‚Äì** komplex/umfangreich, schwer zu parallelisieren, √Ñnderungen schwer integrierbar, starke Dokumentenorientierung, f√ºr **kleine** Projekte ungeeignet. 

### (4) Serum

Agiles Modell mit **Sprints** (wenige Wochen), **Product Backlog** ‚Üí **Sprint Backlog**, **Daily Serum**, **Sprint Review/Retrospektive**; Teamgr√∂√üe ca. **3‚Äì9** Entwickler.
**+** wenige Regeln, kurze Wege, hohe Flexibilit√§t/Transparenz, **Selbstorganisation**, kontinuierliche Verbesserung, geringer Admin-/Doku-Aufwand.
**‚Äì** fehlender Gesamt√ºberblick, hoher Abstimmungsbedarf, wenige konkrete Handlungsempfehlungen, schwierige **Multi-Team-Koordination**, m√∂gliche Inkompatibilit√§t mit Strukturen. 

### (5) DevOps-Ansatz

Agiles **Development** + stabiler **Operations**-Betrieb in **integrierten IT-Teams**; h√§ufige, qualitativ hochwertige **Auslieferungen**, wichtiger Baustein **Cloud**-orientierter Entwicklung.
**+** schnelleres **Time-to-Market**, hohe Liefertreue, transparente Zusammenarbeit, k√ºrzere Probleml√∂sungszeiten, pr√§zise Auftraggeber-Erf√ºllung, besserer Support.
**‚Äì** m√∂gliche Strukturinkompatibilit√§t, erheblicher **Mindset-/Tool-Wandel** n√∂tig. 

## üõ†Ô∏è 5.3.4 Programmiersprachen und -werkzeuge unterscheiden

### (1) Aufbau von Programmiersprachen

Bestandteile: **Syntax** (Grammatik), **Schl√ºsselw√∂rter**, **Zeichensatz**; Grundfunktionen: Ein-/Ausgabe, **Variablen/Datenstrukturen**, String-Funktionen, Mathematik, **Kontrollstrukturen**. 

### (2) Historische Entwicklung

Von **Maschinensprache**/Lochkarten √ºber **Fortran** (1953) zu C/Familie und modernen Sprachen (**C++**, **Java**, **C#**, **PHP**, **Python**) bis zu neueren wie **Go**, **Rust**, **Swift**. 

### (3) Einteilung

* **Nach Anwendungsgebiet**: z. B. **Fortran/C++/Java** (wissenschaftlich), **COBOL/Java/C#** (kommerziell), **C/C++** (System), **C/C++/C#** (Spiele), **Java/Swift/Objective-C** (Mobile), **HTML/CSS/JavaScript/PHP** (Web), **C#/Java/Python/C++** (Desktop).
* **Nach Generationen** (klassisch, heute nachrangig): **1G** (Maschine), **2G** (Assembler), **3G** (h√∂here prozedurale), **4G** (DB-Sprachen), **5G** (KI-Sprachen).
* **Nach Paradigma**: **imperativ**, **objektorientiert**, **deklarativ** (z. B. Prolog, Lisp/Haskell). 

### (4) Auswahl einer Programmiersprache

Kriterien: **Anwendung/Zielplattform**, Herstellerempfehlungen, bestehende Sprache bei Anpassungen, **Team-Erfahrung/Einarbeitungsaufwand**. Beispiele: **Android ‚Üí Java**, **iOS ‚Üí Objective-C/Swift**, **Windows-Apps ‚Üí C#/C++/VB**, **systemnah ‚Üí C**, **Web ‚Üí JavaScript/PHP**, **Datenanalyse ‚Üí R/SQL**, **Raspberry Pi/Einstieg ‚Üí Python**. Rankings (z. B. **RedMonk**, **TIOBE**, **PYPL**) geben Verbreitungstrends. 

### (5) Frameworks

Arten: **Application**, **Domain**, **Test**, **Web** (z. B. **Symfony**, **Ruby on Rails**, **Django**, **Play**). Beispiel **Spiele-Engines** (Unity, Cry-Engine). Zweck: **Struktur** bereitstellen, Wiederverwendung erh√∂hen, Fokus auf Fachlogik. 

### (6) Programmierwerkzeuge

* **Editor/GUI-Builder**, **Compiler/Interpreter/Assembler**, **Debugger**, **Versionsverwaltung**.
* **IDE** (z. B. **Eclipse**, **Visual Studio**, **PyCharm**); Trend zu **leichtgewichtigen Editoren** mit Plugins (z. B. **Visual Studio Code**).
* **Compiler** vs. **Interpreter**: Vorab-Kompilierung (schnell, aber plattformgebunden) vs. Laufzeit-√úbersetzung (plattformunabh√§ngig, geringere Performance). **Java** kombiniert **Bytecode + Interpreter**. 

---

**Ergebniskern:**

* **Phasenmodell nach IEEE 12207** bildet den roten Faden von **Anforderung** √ºber **Design**, **Implementierung**, **Test**, **Dokumentation**, **Auslieferung** bis **Wartung**.
* **Projektmanagement** ist zentraler Erfolgsfaktor; klassische und **agile** **Vorgehensmodelle** werden je nach Kontext gew√§hlt (u. a. **Wasserfall**, **Spiral**, **V-Modell**, **Serum**, **DevOps**).
* **Sprach-/Werkzeugwahl** folgt **Anwendungsgebiet** und **Teamkompetenz**; **Frameworks** und **IDEs** beschleunigen Entwicklung und Qualit√§tssicherung. 




---
