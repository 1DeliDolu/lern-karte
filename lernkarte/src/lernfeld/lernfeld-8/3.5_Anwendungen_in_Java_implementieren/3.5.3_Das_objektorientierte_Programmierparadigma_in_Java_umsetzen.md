# 🧩 3.5.3 Das objektorientierte Programmierparadigma in Java umsetzen  [Seite: 229]

In diesem Abschnitt wird gezeigt, **wie** zentrale OOP-Konzepte (**Klassen**, **Objekte**, **Zugriffsmodifier**, **Kapselung**, **Vererbung**, **Methoden überschreiben**, **abstrakte Klassen** und **Interfaces**) **in Java konkret implementiert** werden. Dazu gehören u. a. die Arbeit mit **Getter/Setter**, **Konstruktoren/Destruktoren**, das **Erzeugen von Objekten** mit `new`, die Umsetzung von **Einfachvererbung** mit `extends` und die **Mehrfachvererbung über Interfaces** mit `implements`. Ziel ist, die Konzepte praktisch anzuwenden. 

| **Begriff**                | **Definition**                                                                                                                                                                         |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Zugriffsmodifier**       | **public**, **protected**, **private** steuern den Zugriff (innerhalb der Klasse, in abgeleiteten Klassen, von außen). Wird kein Modifier angegeben, gilt der Zugriff als privat.      |
| **Getter/Setter**          | Methoden zur **Kapselung**: Attribute (typisch **private**) werden über **get**/**set** gelesen/gesetzt; Änderungen bleiben auf die Schnittstelle begrenzt.                            |
| **Konstruktor**            | Methode, die beim **Erzeugen eines Objekts** automatisch läuft; initialisiert Attribute; i. d. R. **public**.                                                                          |
| **Destruktor**             | Letzte Methode vor Objektzerstörung; in Java wegen **Garbage Collector** praktisch nicht genutzt.                                                                                      |
| **Objekterzeugung**        | Syntax: `<Klasse> <name> = new <Klasse>();` – danach Zugriff über **Getter/Setter** und eigene Methoden.                                                                               |
| **Vererbung**              | Umsetzung der **Einfachvererbung** mit `extends`; **Mehrfachvererbung** nur **indirekt** über **Interfaces**. Private Attribute der Basisklasse sind nicht direkt zugreifbar.          |
| **Methoden überschreiben** | **Signatur** und **Rückgabetyp** müssen übereinstimmen; Zugriffsrechte dürfen **gelockert**, aber nicht **verschärft** werden; nur **vererbte** Methoden können überschrieben werden.  |
| **Abstrakte Klasse**       | Enthält ggf. **abstrakte Methoden** (ohne Rumpf), ist **nicht instanziierbar**; dient als **Basisklasse**.                                                                             |
| **Interface**              | Sammlung **abstrakter Methoden**/**Konstanten**; Klassen **implementieren** Interfaces mit `implements`; **alle Elemente public**; **mehrere Interfaces** pro Klasse möglich.          |

## 🧱 Klassen definieren & kapseln

* Attribute mit passenden **Zugriffsmodifiern** deklarieren; ohne Angabe werden Komponenten als **privat** behandelt.
* **Getter/Setter** bilden die kontrollierte **Schnittstelle** zur Außenwelt und realisieren **Kapselung**. 

## 🛠️ Konstruktoren, Destruktoren & Objekterzeugung

* **Konstruktor** setzt Startwerte/Reservierungen; Ausführung bei `new`.
* **Destruktor** in Java kaum relevant (Speicherfreigabe automatisch).
* **Objekte** erzeugen und über **Getter/Setter** initialisieren; typische Demonstration am Beispiel **Luftfahrzeug**. 

## 🌳 Vererbung in Java umsetzen

* **Einfachvererbung**: `class Flugzeug extends Luftfahrzeug { ... }` und `class Heißluftballon extends Luftfahrzeug { ... }`.
* **Private** Attribute der Basisklasse sind in Unterklassen **nicht** direkt zugreifbar; ggf. **protected** setzen oder **Getter/Setter** nutzen. 

## ✏️ Methoden überschreiben (Override)

* Bedingungen für korrektes **Überschreiben**:

  1. **Methodenkopf** (Name/Parameter) und **Rückgabetyp** stimmen überein.
  2. **Zugriff** der überschreibenden Methode nicht **strenger** als im Original (Lockerung erlaubt).
  3. Methode muss **vererbt** sein (private Methoden sind ausgeschlossen).
* Beispiel: **`getDaten()`** in **Flugzeug**/**Heißluftballon** erweitert die Ausgabe der Basisklasse. 

## 🧰 Abstrakte Klassen

* **Abstrakte Klassen** definieren gemeinsame Struktur/Verhalten; **Instanziierung nicht möglich**.
* Beispiel: `abstract class Luftfahrzeug { public abstract String getDaten(); }` und angepasstes **Hauptprogramm** mit Unterklassen. 

## 🔌 Interfaces (Mehrfachvererbung über Schnittstellen)

* **Interface** definiert **abstrakte Operationen**; Klassen implementieren mit `implements`.
* Unterschiede zur **abstrakten Klasse**: alle Methoden **abstrakt**, **Sichtbarkeit public**, **mehrere** Interfaces pro Klasse möglich.
* Beispiel: **`IObjekt2D`** mit **`berechneFläche()`** und **`berechneUmfang()`**; Implementierung in **Rechteck**/**Kreis**.

## 🧪 Durchgehendes Beispiel: „Luftfahrzeug“

* Vollständige Klasse **Luftfahrzeug** (Attribute, **Konstruktor**, **Getter/Setter**, **getDaten()**);
* Erzeugen und Initialisieren von **Objekten** im **Hauptprogramm**;
* Erweiterung durch **Unterklassen** und **Überschreiben** der Ausgabemethode.

## ✅ Lernkontrolle & Übungen (Auszug)

* Richtig/Falsch-Fragen u. a. zu **abstrakten Klassen**, **Interfaces/Mehrfachvererbung**, **Konstruktor-Überladung** und **Überschreiben**.
* Praxisaufgaben: z. B. **Server-Hierarchie** in Java implementieren (Eigenschaften ergänzen, **Konstruktoren überladen**, **Methoden überschreiben**, Hauptprogramm schreiben). 

---

**Ergebnis:** Der Abschnitt liefert eine **konkrete Umsetzungsschablone** für OOP in Java – von **Kapselung** über **Vererbung**/**Override** bis zu **abstrakten Klassen** und **Interfaces** – einschließlich **Code-Mustern** und **Übungsaufgaben** zur direkten Anwendung.
