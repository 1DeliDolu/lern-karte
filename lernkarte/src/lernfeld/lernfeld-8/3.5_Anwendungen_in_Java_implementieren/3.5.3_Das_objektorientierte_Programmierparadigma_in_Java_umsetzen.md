# ğŸ§© 3.5.3 Das objektorientierte Programmierparadigma in Java umsetzen  [Seite: 229]

In diesem Abschnitt wird gezeigt, **wie** zentrale OOP-Konzepte (**Klassen**, **Objekte**, **Zugriffsmodifier**, **Kapselung**, **Vererbung**, **Methoden Ã¼berschreiben**, **abstrakte Klassen** und **Interfaces**) **in Java konkret implementiert** werden. Dazu gehÃ¶ren u. a. die Arbeit mit **Getter/Setter**, **Konstruktoren/Destruktoren**, das **Erzeugen von Objekten** mit `new`, die Umsetzung von **Einfachvererbung** mit `extends` und die **Mehrfachvererbung Ã¼ber Interfaces** mit `implements`. Ziel ist, die Konzepte praktisch anzuwenden. 

| **Begriff**                | **Definition**                                                                                                                                                                         |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Zugriffsmodifier**       | **public**, **protected**, **private** steuern den Zugriff (innerhalb der Klasse, in abgeleiteten Klassen, von auÃŸen). Wird kein Modifier angegeben, gilt der Zugriff als privat.      |
| **Getter/Setter**          | Methoden zur **Kapselung**: Attribute (typisch **private**) werden Ã¼ber **get**/**set** gelesen/gesetzt; Ã„nderungen bleiben auf die Schnittstelle begrenzt.                            |
| **Konstruktor**            | Methode, die beim **Erzeugen eines Objekts** automatisch lÃ¤uft; initialisiert Attribute; i. d. R. **public**.                                                                          |
| **Destruktor**             | Letzte Methode vor ObjektzerstÃ¶rung; in Java wegen **Garbage Collector** praktisch nicht genutzt.                                                                                      |
| **Objekterzeugung**        | Syntax: `<Klasse> <name> = new <Klasse>();` â€“ danach Zugriff Ã¼ber **Getter/Setter** und eigene Methoden.                                                                               |
| **Vererbung**              | Umsetzung der **Einfachvererbung** mit `extends`; **Mehrfachvererbung** nur **indirekt** Ã¼ber **Interfaces**. Private Attribute der Basisklasse sind nicht direkt zugreifbar.          |
| **Methoden Ã¼berschreiben** | **Signatur** und **RÃ¼ckgabetyp** mÃ¼ssen Ã¼bereinstimmen; Zugriffsrechte dÃ¼rfen **gelockert**, aber nicht **verschÃ¤rft** werden; nur **vererbte** Methoden kÃ¶nnen Ã¼berschrieben werden.  |
| **Abstrakte Klasse**       | EnthÃ¤lt ggf. **abstrakte Methoden** (ohne Rumpf), ist **nicht instanziierbar**; dient als **Basisklasse**.                                                                             |
| **Interface**              | Sammlung **abstrakter Methoden**/**Konstanten**; Klassen **implementieren** Interfaces mit `implements`; **alle Elemente public**; **mehrere Interfaces** pro Klasse mÃ¶glich.          |

## ğŸ§± Klassen definieren & kapseln

* Attribute mit passenden **Zugriffsmodifiern** deklarieren; ohne Angabe werden Komponenten als **privat** behandelt.
* **Getter/Setter** bilden die kontrollierte **Schnittstelle** zur AuÃŸenwelt und realisieren **Kapselung**. 

## ğŸ› ï¸ Konstruktoren, Destruktoren & Objekterzeugung

* **Konstruktor** setzt Startwerte/Reservierungen; AusfÃ¼hrung bei `new`.
* **Destruktor** in Java kaum relevant (Speicherfreigabe automatisch).
* **Objekte** erzeugen und Ã¼ber **Getter/Setter** initialisieren; typische Demonstration am Beispiel **Luftfahrzeug**. 

## ğŸŒ³ Vererbung in Java umsetzen

* **Einfachvererbung**: `class Flugzeug extends Luftfahrzeug { ... }` und `class HeiÃŸluftballon extends Luftfahrzeug { ... }`.
* **Private** Attribute der Basisklasse sind in Unterklassen **nicht** direkt zugreifbar; ggf. **protected** setzen oder **Getter/Setter** nutzen. 

## âœï¸ Methoden Ã¼berschreiben (Override)

* Bedingungen fÃ¼r korrektes **Ãœberschreiben**:

  1. **Methodenkopf** (Name/Parameter) und **RÃ¼ckgabetyp** stimmen Ã¼berein.
  2. **Zugriff** der Ã¼berschreibenden Methode nicht **strenger** als im Original (Lockerung erlaubt).
  3. Methode muss **vererbt** sein (private Methoden sind ausgeschlossen).
* Beispiel: **`getDaten()`** in **Flugzeug**/**HeiÃŸluftballon** erweitert die Ausgabe der Basisklasse. 

## ğŸ§° Abstrakte Klassen

* **Abstrakte Klassen** definieren gemeinsame Struktur/Verhalten; **Instanziierung nicht mÃ¶glich**.
* Beispiel: `abstract class Luftfahrzeug { public abstract String getDaten(); }` und angepasstes **Hauptprogramm** mit Unterklassen. 

## ğŸ”Œ Interfaces (Mehrfachvererbung Ã¼ber Schnittstellen)

* **Interface** definiert **abstrakte Operationen**; Klassen implementieren mit `implements`.
* Unterschiede zur **abstrakten Klasse**: alle Methoden **abstrakt**, **Sichtbarkeit public**, **mehrere** Interfaces pro Klasse mÃ¶glich.
* Beispiel: **`IObjekt2D`** mit **`berechneFlÃ¤che()`** und **`berechneUmfang()`**; Implementierung in **Rechteck**/**Kreis**.

## ğŸ§ª Durchgehendes Beispiel: â€Luftfahrzeugâ€œ

* VollstÃ¤ndige Klasse **Luftfahrzeug** (Attribute, **Konstruktor**, **Getter/Setter**, **getDaten()**);
* Erzeugen und Initialisieren von **Objekten** im **Hauptprogramm**;
* Erweiterung durch **Unterklassen** und **Ãœberschreiben** der Ausgabemethode.

## âœ… Lernkontrolle & Ãœbungen (Auszug)

* Richtig/Falsch-Fragen u. a. zu **abstrakten Klassen**, **Interfaces/Mehrfachvererbung**, **Konstruktor-Ãœberladung** und **Ãœberschreiben**.
* Praxisaufgaben: z. B. **Server-Hierarchie** in Java implementieren (Eigenschaften ergÃ¤nzen, **Konstruktoren Ã¼berladen**, **Methoden Ã¼berschreiben**, Hauptprogramm schreiben). 

---

**Ergebnis:** Der Abschnitt liefert eine **konkrete Umsetzungsschablone** fÃ¼r OOP in Java â€“ von **Kapselung** Ã¼ber **Vererbung**/**Override** bis zu **abstrakten Klassen** und **Interfaces** â€“ einschlieÃŸlich **Code-Mustern** und **Ãœbungsaufgaben** zur direkten Anwendung.
