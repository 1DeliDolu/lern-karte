# 🧩 3.7.1 Ein geeignetes Datenmodell auswählen [Seite: 263]

Ziel dieses Abschnitts ist, **Datenmodelle** zu unterscheiden und bedarfsgerecht auszuwählen. Ausgangspunkt ist die Einteilung von Daten in **strukturierte**, **semistrukturierte** und **unstrukturierte** Daten. Bis in die späten 2000er dominierten strukturierte Daten und damit **relationale** Lösungsansätze. Mit neuen IT-Technologien wuchsen jedoch Volumen und Vielfalt der (insb. unstrukturierten) Daten stark; damit etablierte sich der Begriff **Big Data** als Verarbeitung großer, komplexer, sich schnell ändernder Datenmengen. Andere Modelle wie **objektorientierte Datenbanken** setzten sich wegen ihrer Komplexität nicht durch. 

* | **Begriff**: | **Definition (kurz)** |
* | **Strukturierte Daten**: | Daten mit festem Schema (z. B. Tabellen). |
* | **Semistrukturierte Daten**: | Daten mit teils flexiblem Aufbau (z. B. E-Mails/JSON). |
* | **Unstrukturierte Daten**: | Daten ohne vorgegebenes Schema (z. B. Text, Bild, Audio, Video). |
* | **Big Data**: | Verarbeitung großer, komplexer, dynamischer Datenmengen. |
* | **Relationale DB**: | Tabellenbasiert, **ACID**-konform, typ. vertikale Skalierung. |
* | **NoSQL-DB**: | Dokument/Graph/Key-Value/Spalte; flexibel, horizontale Skalierung, oft **BASE**/**Eventual Consistency**.

## 🔎 Datenarten & Beispiele

* Einteilung: **strukturiert**, **semistrukturiert**, **unstrukturiert**.
* Beispiele unstrukturierter Daten: **Fließtext**, **3D-Modelle**, **technische Zeichnungen**, **Fotos**/**Röntgenbilder**/**Satellitenbilder**, **Musik/Sprache/Geräusche**, **Film/Animation/Videokonferenz**. 

## 📈 Entwicklungstrend

* Treiber des Datenwachstums: **IoT**, **Künstliche Intelligenz**, **5G-Mobilfunk**, **Edge Computing**, **datenbasierte Geschäftsmodelle**.
* Folge: steigender Bedarf an Modellen, die auch **un-/semistrukturierte** Daten flexibel speichern und verarbeiten können. 

## ⚖️ Relational vs. NoSQL – Gegenüberstellung

* **Datenmodell**: Relational (Tabellen, Beziehungen) vs. **NoSQL** (verschiedene Modelle: Dokument, Graph, Key-Value, Spalte).
* **Schema**: Relational **fest** (Schemaanpassung aufwendig) vs. NoSQL **flexibel** (strukturierte, semi- und unstrukturierte Daten gemeinsam möglich).
* **Skalierung**: Relational meist **vertikal** (leistungsfähiger Einzelserver) vs. NoSQL **horizontal** (weitgehend beliebig erweiterbar).
* **Konsistenzmodell**: Relationale Systeme setzen **ACID** um; NoSQL verlagert häufig den Fokus auf **Verfügbarkeit**/**BASE** mit **eventual consistency**.
* **Einsatzgebiete (Orientierung)**: Relationale DBs für **stabile Schemata**, viele **Entitäten/Beziehungen** und strenge **ACID**-Anforderungen (z. B. „Geld“); NoSQL für Szenarien mit **hoher Flexibilitäts-/Skalierungsanforderung** und **heterogenen Daten**.

## 🎯 Auswahlprinzip (bedarfsorientiert)

* Prüfkriterien: **Datenart** (strukturiert vs. semi/unstrukturiert), **Änderungsdynamik** des Schemas, **Skalierungsbedarf** (vertikal vs. horizontal), **Transaktionssicherheit** (**ACID**-Pflicht?), **Leistungsanforderungen**.
* Entscheidungsregel aus dem Text: **NoSQL** ist für bestimmte Anwendungsgebiete **spezialisiert** und dort sehr leistungsfähig; **relationale Datenbanken** bleiben **unverzichtbar**, wenn **komplexe, unveränderliche Schemata** und **ACID** gefordert sind. Die Abwägung beeinflusst den anschließenden **Designprozess**. 

---

### 📝 Merksätze

* **Modell folgt Use-Case**: Stabil & ACID-kritisch → **relational**; flexibel, heterogene/rasch wachsende Daten & horizontale Skalierung → **NoSQL**.
* **Big Data ≠ nur „viel“**: Es geht um **Menge + Komplexität + Änderungsdynamik**. 
