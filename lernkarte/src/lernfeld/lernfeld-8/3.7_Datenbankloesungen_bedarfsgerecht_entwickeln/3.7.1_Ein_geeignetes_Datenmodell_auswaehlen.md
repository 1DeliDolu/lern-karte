# ğŸ§© 3.7.1 Ein geeignetes Datenmodell auswÃ¤hlen [Seite: 263]

Ziel dieses Abschnitts ist, **Datenmodelle** zu unterscheiden und bedarfsgerecht auszuwÃ¤hlen. Ausgangspunkt ist die Einteilung von Daten in **strukturierte**, **semistrukturierte** und **unstrukturierte** Daten. Bis in die spÃ¤ten 2000er dominierten strukturierte Daten und damit **relationale** LÃ¶sungsansÃ¤tze. Mit neuen IT-Technologien wuchsen jedoch Volumen und Vielfalt der (insb. unstrukturierten) Daten stark; damit etablierte sich der Begriff **Big Data** als Verarbeitung groÃŸer, komplexer, sich schnell Ã¤ndernder Datenmengen. Andere Modelle wie **objektorientierte Datenbanken** setzten sich wegen ihrer KomplexitÃ¤t nicht durch. 

* | **Begriff**: | **Definition (kurz)** |
* | **Strukturierte Daten**: | Daten mit festem Schema (z. B. Tabellen). |
* | **Semistrukturierte Daten**: | Daten mit teils flexiblem Aufbau (z. B. E-Mails/JSON). |
* | **Unstrukturierte Daten**: | Daten ohne vorgegebenes Schema (z. B. Text, Bild, Audio, Video). |
* | **Big Data**: | Verarbeitung groÃŸer, komplexer, dynamischer Datenmengen. |
* | **Relationale DB**: | Tabellenbasiert, **ACID**-konform, typ. vertikale Skalierung. |
* | **NoSQL-DB**: | Dokument/Graph/Key-Value/Spalte; flexibel, horizontale Skalierung, oft **BASE**/**Eventual Consistency**.

## ğŸ” Datenarten & Beispiele

* Einteilung: **strukturiert**, **semistrukturiert**, **unstrukturiert**.
* Beispiele unstrukturierter Daten: **FlieÃŸtext**, **3D-Modelle**, **technische Zeichnungen**, **Fotos**/**RÃ¶ntgenbilder**/**Satellitenbilder**, **Musik/Sprache/GerÃ¤usche**, **Film/Animation/Videokonferenz**. 

## ğŸ“ˆ Entwicklungstrend

* Treiber des Datenwachstums: **IoT**, **KÃ¼nstliche Intelligenz**, **5G-Mobilfunk**, **Edge Computing**, **datenbasierte GeschÃ¤ftsmodelle**.
* Folge: steigender Bedarf an Modellen, die auch **un-/semistrukturierte** Daten flexibel speichern und verarbeiten kÃ¶nnen. 

## âš–ï¸ Relational vs. NoSQL â€“ GegenÃ¼berstellung

* **Datenmodell**: Relational (Tabellen, Beziehungen) vs. **NoSQL** (verschiedene Modelle: Dokument, Graph, Key-Value, Spalte).
* **Schema**: Relational **fest** (Schemaanpassung aufwendig) vs. NoSQL **flexibel** (strukturierte, semi- und unstrukturierte Daten gemeinsam mÃ¶glich).
* **Skalierung**: Relational meist **vertikal** (leistungsfÃ¤higer Einzelserver) vs. NoSQL **horizontal** (weitgehend beliebig erweiterbar).
* **Konsistenzmodell**: Relationale Systeme setzen **ACID** um; NoSQL verlagert hÃ¤ufig den Fokus auf **VerfÃ¼gbarkeit**/**BASE** mit **eventual consistency**.
* **Einsatzgebiete (Orientierung)**: Relationale DBs fÃ¼r **stabile Schemata**, viele **EntitÃ¤ten/Beziehungen** und strenge **ACID**-Anforderungen (z. B. â€Geldâ€œ); NoSQL fÃ¼r Szenarien mit **hoher FlexibilitÃ¤ts-/Skalierungsanforderung** und **heterogenen Daten**.

## ğŸ¯ Auswahlprinzip (bedarfsorientiert)

* PrÃ¼fkriterien: **Datenart** (strukturiert vs. semi/unstrukturiert), **Ã„nderungsdynamik** des Schemas, **Skalierungsbedarf** (vertikal vs. horizontal), **Transaktionssicherheit** (**ACID**-Pflicht?), **Leistungsanforderungen**.
* Entscheidungsregel aus dem Text: **NoSQL** ist fÃ¼r bestimmte Anwendungsgebiete **spezialisiert** und dort sehr leistungsfÃ¤hig; **relationale Datenbanken** bleiben **unverzichtbar**, wenn **komplexe, unverÃ¤nderliche Schemata** und **ACID** gefordert sind. Die AbwÃ¤gung beeinflusst den anschlieÃŸenden **Designprozess**. 

---

### ğŸ“ MerksÃ¤tze

* **Modell folgt Use-Case**: Stabil & ACID-kritisch â†’ **relational**; flexibel, heterogene/rasch wachsende Daten & horizontale Skalierung â†’ **NoSQL**.
* **Big Data â‰  nur â€vielâ€œ**: Es geht um **Menge + KomplexitÃ¤t + Ã„nderungsdynamik**. 
