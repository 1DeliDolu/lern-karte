# üóÑÔ∏è 3.7 Datenbankl√∂sungen bedarfsgerecht entwickeln [Seite: 262]

Zur system√ºbergreifenden Bereitstellung von Daten werden passende Datenbankl√∂sungen geplant und umgesetzt. Das Kapitel vertieft vorhandenes Wissen zu relationalen Datenbanken und SQL und erweitert es um NoSQL, Programmzugriffe (Java/Python) sowie Cloud-Modelle. Ziel ist die methodische Auswahl und Realisierung einer L√∂sung, die dem Bedarf (Datenart, Skalierung, Betrieb) entspricht. 

* | **Begriff**: | **Definition (kurz)** |
* | **ACID**: | Transaktionseigenschaften **Atomicity**, **Consistency**, **Isolation**, **Durability**. |
* | **BASE**: | Gegenmodell zu ACID: **Basically Available**, **Soft State**, **Eventual Consistency**. |
* | **ER-Modell**: | Konzeptionelles Modell mit **Entit√§tstyp**, **Attribut**, **Beziehung**, **Kardinalit√§t**. |
* | **Normalformen (1NF/2NF/3NF)**: | Regeln zur Reduktion von **Redundanz** und Sicherung der **Datenintegrit√§t**. |
* | **JOIN/UNION**: | **Mehrtabellenabfragen** bzw. **Vereinigung** von Ergebnismengen in SQL. |
* | **GRANT/REVOKE**: | **Rechtevergabe** und -entzug in SQL (Benutzer/Objekte). |
* | **JDBC**: | Java-Zugriff √ºber **DriverManager**, **Connection**, **Statement**, **ResultSet**, **SQLException**. |
* | **NoSQL-Modelle**: | **Dokumenten-**, **Graph-**, **Key-Value-**, **Spaltenorientierte** Datenbanken. |
* | **PyMongo**: | Python-Bibliothek f√ºr **MongoDB** mit **insert_one**, **insert_many**, **find_one**, **find**. |
* | **DBaaS**: | Cloud-Betrieb als Dienst: **selbstverwaltet**, **automatisiert**, **verwaltet**, **autonom**. |

## üß© 3.7.1 Ein geeignetes Datenmodell ausw√§hlen

* Unterscheidung nach Datenarten (**strukturiert**, **semistrukturiert**, **unstrukturiert**) und Anwendungsfall.
* **Relationale DB** f√ºr stabiles Schema mit vielen Entit√§ten/Beziehungen und strenger **ACID**-Einhaltung (z. B. Finanzwesen).
* **NoSQL** erg√§nzt Relationen f√ºr Big-Data-/Echtzeitszenarien; Trade-off Richtung **BASE** (h√∂here Verf√ºgbarkeit, eventual consistency).
* **Skalierung**: Relationale Systeme oft vertikal, NoSQL h√§ufiger **horizontal** √ºber Sharding/Replikation. Entscheidung beeinflusst den weiteren Designprozess. 

## üß≠ 3.7.2 Prozess des Designs relationaler Datenbanken

Vier Phasen eines qualit√§tsgesicherten Designs (DBMS-unabh√§ngig ‚Üí DBMS-abh√§ngig):

1. **Analysephase**: Anforderungen ermitteln/strukturieren (informelle Problembeschreibung).
2. **Konzeptionelle Phase**: formale Beschreibung (typisch **ER-Modell**).
3. **Logische Phase**: ER ‚Üí **relationales Modell**, Optimierung durch **Normalisierung**.
4. **Implementationsphase**: √úbersetzung in physisches **Datenbankschema** (SQL, Datentypen, Schl√ºssel, Constraints).
   Abk√ºrzungen sind riskant: Schlechtes **logisches/physisches Design** f√ºhrt sp√§ter zu Problemen.

## üß± 3.7.3 Relationale Datenmodelle normalisieren

* Ziel: **Datenintegrit√§t**, Minimierung von **Anomalien**/**Redundanz**.
* **1NF** (atomare Werte), **2NF** (vollst√§ndige Abh√§ngigkeit von ganzem Schl√ºssel), **3NF** (keine **transitiven Abh√§ngigkeiten**).
* Weitere Formen (**BCNF**, **4NF**, **5NF**) existieren, sind in der Praxis weniger zentral.
* **√úbernormalisierung** kann Nachteile haben: viele kleine Tabellen, komplexe **JOINs**, Performance-Einbu√üen, zus√§tzlicher Speicherbedarf durch Schl√ºssel.

## üßÆ 3.7.4 SQL-Wissen erweitern und anwenden

* √úberblick zentrale Anweisungen: **CREATE/DROP DATABASE**, **CREATE/ALTER/DROP TABLE**, **INSERT/UPDATE/DELETE**, **SELECT** inkl. **Aggregat-, Vergleichs-, Rechen-, logischer Operatoren**; Arbeit mit einem Beispieldatenmodell (‚ÄûOrtsverwaltung‚Äú).
* **Mehrtabellenabfragen**: **INNER/LEFT/RIGHT JOIN**, **UNION** (Vereinigung von Ergebnismengen).
* **Unterabfragen**: in **()**; bei mehreren R√ºckgabewerten **Mengenoperatoren** (**IN/ANY/ALL**); **ORDER BY/UNION** in Unterabfragen unzul√§ssig.
* **Rechteverwaltung**: **CREATE USER**, **GRANT ‚Ä¶ [WITH GRANT OPTION]**, **REVOKE**.

## ‚òï 3.7.5 MySQL mit Java (JDBC) ansprechen

* **Treiber laden** (`Class.forName(...)`), **Verbindung** aufbauen (`DriverManager.getConnection(...)`), **Statement** erzeugen.
* **Daten √§ndern**: `executeUpdate(...)` (z. B. **INSERT**, **UPDATE**, **DELETE**, DDL).
* **Daten lesen**: `executeQuery(...)` ‚Üí **ResultSet** verarbeiten.
* **Ressourcen schlie√üen** und **Exceptions** (**SQLException**) behandeln.

## üçÉ 3.7.6 NoSQL-Datenbanken und Datenmodelle unterscheiden

* **Dokumentenorientiert**: flexible **Dokumente** (h√§ufig **JSON**), Schema variabel; gut f√ºr **CMS/Blogs**.
* **Graph**: **Knoten**, **Kanten**, **Eigenschaften**; ideal f√ºr vernetzte Dom√§nen (z. B. Social-Netzwerke).
* **Key-Value**: extrem schnell und einfach (**Schl√ºssel** ‚Üí **Wert**); eingeschr√§nkte Abfragen; hervorragend skalierbar (horizontal).
* **Spaltenorientiert**: Speicherung spaltenweise; sehr effizient f√ºr analytische Abfragen/Data-Warehouse-Szenarien.

## üêç 3.7.7 MongoDB mit Python (PyMongo)

* **MongoDB**: dokumentenbasiertes NoSQL-DBMS; JSON-√§hnliche Dokumente; plattform√ºbergreifend; **Open Source**.
* **Vorbereitung**: Installation von **MongoDB** und **PyMongo** (`python -m pip install pymongo`).
* **Grundoperationen**: `MongoClient(...)` ‚Üí DB/Collection; **Schreiben** (`insert_one`, `insert_many`), **Lesen** (`find_one`, `find`).
* **Begriffe**: **Collection** ‚âà Tabelle im relationalen Modell; **Dokument** ‚âà Datensatz.

## ‚òÅÔ∏è 3.7.8 Cloud-basierte Datenbankl√∂sungen

* **Vorteile**: **Flexibilit√§t**, schnelle **Markteinf√ºhrung**, reduzierte **Betriebsrisiken** (z. B. durch SLAs/HA), **Pay-per-Use**/**dynamische Skalierung** ‚Üí niedrigere Kosten.
* **Management-Varianten**: **selbstverwaltet**, **automatisiert**, **verwaltet**, **autonom** (weitreichende Automatisierung via **ML**/Automatisierung).
* **Anbieter√ºberblick** (DBaaS-Portfolio & Migration):

  * **Amazon**: Relationale (**SQL Server**, **Oracle**, **MySQL**, **PostgreSQL**, **Aurora**), NoSQL (**DocumentDB**, **Neptune**, **DynamoDB**), **Redshift**; Migrationstools: **AWS DMS**, **Schema Conversion Tool**.
  * **Microsoft**: **Azure SQL Database**, **MySQL/PostgreSQL/MariaDB**, **SQL Data Warehouse**; NoSQL (**Cosmos DB**, **Table Storage**, **Azure Cache for Redis**); **Azure Database Migration Service**.
  * **Google**: **Cloud Spanner**, **Cloud SQL**; NoSQL (**Bigtable**, **Cloud Firestore**, **Firebase Realtime Database**); Migrationstools teils noch im Aufbau/Partnerl√∂sung.
  * **Oracle**: Fokus **autonome Datenbanken** (z. B. **Autonomous Database/Data Warehouse**), zus√§tzlich **MySQL**, **Oracle NoSQL**; eingeschr√§nkte heterogene Migrationstools.

---

### üîé Merks√§tze & Pr√ºfungsfokus

* **Modellwahl folgt dem Use Case**: ACID-strikt & komplexe Beziehungen ‚Üí relational; hohe Flexibilit√§t/Skalierung/unklare Strukturen ‚Üí passendes NoSQL-Modell. 
* **Design zuerst denken, dann bauen**: Analyse ‚Üí ER ‚Üí relational + **Normalisierung** ‚Üí physisches Schema. 
* **SQL sicher beherrschen**: Joins, Unterabfragen-Regeln, Rechteverwaltung. 
* **Zugriffswege kennen**: **JDBC** f√ºr MySQL/Java, **PyMongo** f√ºr MongoDB/Python.
* **Cloud-Optionen vergleichen**: Betriebsmodell, Produktbreite, **Migration**/**SLA** entscheiden mit. 
