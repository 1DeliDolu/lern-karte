# üß© 3.6.1 Das objektorientierte Programmierparadigma in Python umsetzen [Seite: 250]

In diesem Abschnitt wird das **objektorientierte Programmierparadigma (OOP)** in Python im Detail erl√§utert. Ziel ist es, Klassen, Objekte und zentrale OOP-Konzepte praktisch zu verstehen und umzusetzen. Python wird als **nicht rein objektorientierte, aber objektf√§hige** Sprache dargestellt ‚Äì sie unterst√ºtzt alle wichtigen OOP-Prinzipien (Abstraktion, Kapselung, Vererbung, Polymorphie), jedoch mit **vereinfachter Syntax** und **eigenst√§ndigen Sprachregeln**.

---

## üéØ Lernziele

* Verst√§ndnis der **OOP-Grundprinzipien** in Python
* Implementieren eigener **Klassen** mit **Attributen** und **Methoden**
* Anwendung von **Konstruktoren**, **Destruktoren**, **Getter/Setter** und **Namenskonventionen**
* Verwendung von **Vererbung**, **Abstraktion** und **Polymorphie** in Python
* Umsetzung einfacher Beispiele (z. B. ‚ÄûMusikinstrument‚Äú, ‚ÄûGitarre‚Äú, ‚ÄûSaxophon‚Äú)

---

## üß± Grundprinzipien der Objektorientierung

| **Begriff**          | **Beschreibung / Umsetzung in Python**                                                                                        |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| **Klasse**           | Definition mit `class`-Schl√ºsselwort. Enth√§lt Attribute (Daten) und Methoden (Funktionen). Beispiel: `class Musikinstrument:` |
| **Objekt (Instanz)** | Wird mit `obj = Klassenname()` erzeugt; jedes Objekt ist eine Instanz einer Klasse.                                           |
| **Abstraktion**      | Relevante Eigenschaften werden in Klassen modelliert; unn√∂tige Details werden ausgeblendet.                                   |
| **Kapselung**        | Daten werden durch Namenskonventionen gesch√ºtzt (`_` oder `__`). Zugriff erfolgt √ºber **Getter** und **Setter**.              |
| **Vererbung**        | Klassen k√∂nnen von Basisklassen erben: `class Gitarre(Musikinstrument):`                                                      |
| **Polymorphie**      | Gleichnamige Methoden verhalten sich je nach Klasse unterschiedlich (z. B. √úberschreiben von Methoden).                       |

---

## ‚öôÔ∏è Klassenaufbau und Zugriffskonventionen

* Python verwendet **keine Schl√ºsselw√∂rter f√ºr Sichtbarkeiten** (wie `private` oder `public` in Java), sondern **Namenskonventionen**:

  * `attribut` ‚Üí **√∂ffentlich** (public)
  * `_attribut` ‚Üí **gesch√ºtzt** (protected, nur konventionell)
  * `__attribut` ‚Üí **privat** (private, wird intern umbenannt: Name Mangling)

* **Getter- und Setter-Methoden** erm√∂glichen kontrollierten Zugriff:

  ```python
  def get_name(self):
      return self.__name

  def set_name(self, name):
      self.__name = name
  ```

---

## üèóÔ∏è Konstruktoren und Destruktoren

* **Konstruktor:** Wird beim Erzeugen eines Objekts automatisch aufgerufen.

  ```python
  def __init__(self, name, preis):
      self.__name = name
      self.__preis = preis
  ```

  * Der erste Parameter **`self`** verweist auf die aktuelle Instanz.
  * Python kennt **nur einen Konstruktor** pro Klasse; **√úberladung** ist nicht m√∂glich (Parameter m√ºssen optional gestaltet werden).

* **Destruktor:** Wird kurz vor dem L√∂schen eines Objekts aufgerufen (selten manuell genutzt).

  ```python
  def __del__(self):
      print("Objekt gel√∂scht")
  ```

---

## üß¨ Vererbung und √úberschreiben

* Eine Klasse kann von einer anderen erben:

  ```python
  class Gitarre(Musikinstrument):
      def __init__(self, name, preis, saiten):
          super().__init__(name, preis)
          self.__saiten = saiten
  ```
* **`super()`** ruft den Konstruktor der Oberklasse auf.
* Methoden der Basisklasse k√∂nnen in der Unterklasse **√ºberschrieben** werden (Override):

  ```python
  def get_daten(self):
      return f"{super().get_daten()}, {self.__saiten} Saiten"
  ```

---

## üß± Abstraktion und Interfaces

* Python bietet keine eigenen **Interfaces**, verwendet aber **abstrakte Basisklassen** (Abstract Base Classes, ABC):

  ```python
  from abc import ABC, abstractmethod

  class Musikinstrument(ABC):
      @abstractmethod
      def get_daten(self):
          pass
  ```
* Abstrakte Klassen k√∂nnen **nicht instanziiert** werden.
* Unterklassen m√ºssen alle abstrakten Methoden implementieren, sonst sind sie selbst abstrakt.

---

## üí° Beispiel: ‚ÄûMusikinstrument‚Äú-Hierarchie

```python
from abc import ABC, abstractmethod

class Musikinstrument(ABC):
    def __init__(self, name, preis):
        self.__name = name
        self.__preis = preis

    @abstractmethod
    def get_daten(self):
        pass

class Gitarre(Musikinstrument):
    def __init__(self, name, preis, saiten):
        super().__init__(name, preis)
        self.__saiten = saiten

    def get_daten(self):
        return f"Gitarre: {self.__saiten} Saiten"

class Saxophon(Musikinstrument):
    def __init__(self, name, preis, tonumfang):
        super().__init__(name, preis)
        self.__tonumfang = tonumfang

    def get_daten(self):
        return f"Saxophon: {self.__tonumfang} Oktaven"
```

**Verwendung:**

```python
instrumente = [Gitarre("E-Gitarre", 350, 6), Saxophon("Alt-Saxophon", 420, 2)]
for inst in instrumente:
    print(inst.get_daten())
```

---

## üß† Wichtige Merkmale und Einschr√§nkungen

* Python unterst√ºtzt **keine echte Methoden√ºberladung**:
  ‚Üí Methoden m√ºssen √ºber **optionale Parameter** oder **Variablenargumente (`*args`)** angepasst werden.
* **Mehrfachvererbung** ist m√∂glich, aber un√ºbersichtlich ‚Äì nur bei Bedarf einsetzen.
* **Destruktoren** werden vom Garbage Collector automatisch aufgerufen ‚Äì kein deterministischer Zeitpunkt.
* **Typisierung** ist dynamisch, kann aber mit **Type Hints** unterst√ºtzt werden (`def get_name(self) -> str:`).

---

## ‚úÖ Zusammenfassung der zentralen Punkte

1. **OOP in Python** nutzt dieselben Prinzipien wie Java oder C#, jedoch ohne feste Sichtbarkeitsregeln.
2. **Klassen** werden mit `class` definiert, **Objekte** mit `()` erzeugt.
3. **`__init__`** ist der Konstruktor, **`__del__`** optional der Destruktor.
4. **Vererbung** erfolgt √ºber Klammern: `class Unterklasse(Oberklasse):`.
5. **Abstrakte Klassen** werden mit `ABC` und `@abstractmethod` realisiert.
6. **Methoden√ºberladung** ist nur eingeschr√§nkt m√∂glich.
7. **Namenskonventionen** sichern die Kapselung von Attributen.
8. Die Anwendung erfolgt meist in kleinen **Projekten oder √úbungsdom√§nen** (z. B. Musik-Store).

