# 2.2.1 Grundlegende Datenstrukturen beschreiben


<html>
<head>
<style>
body {
  font-family: "Segoe UI", Roboto, sans-serif;
  color: #000;
  line-height: 1.6;
  background-color: #fff;
}
h1, h2, h3 {
  color: #111;
  border-bottom: 2px solid #ddd;
  padding-bottom: 4px;
}
ul {
  margin-left: 20px;
}
code {
  background: #f4f4f4;
  padding: 2px 5px;
  border-radius: 4px;
  font-family: monospace;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin: 10px 0;
}
th, td {
  border: 1px solid #ccc;
  padding: 6px 10px;
  text-align: left;
}
th {
  background-color: #f9f9f9;
}
blockquote {
  border-left: 4px solid #999;
  padding-left: 10px;
  font-style: italic;
  color: #333;
}
</style>
</head>
<body>

<h2>Allgemeines Verständnis</h2>
<ul>
  <li>Datenstrukturen organisieren und verwalten Daten effizient.</li>
  <li>Sie bestimmen, wie Daten gespeichert, gelesen, gesucht, eingefügt und gelöscht werden.</li>
  <li>Die Auswahl hängt ab von Datenart, Datenmenge und Anforderungen an Geschwindigkeit und Speicherbedarf.</li>
  <li>Effizienz = <strong>geringer Speicherverbrauch</strong> + <strong>schnelle Operationen</strong>.</li>
</ul>

<h2>Grundlegende Operationen</h2>
<ul>
  <li>Lesen/Schreiben von Werten</li>
  <li>Suchen nach Elementen</li>
  <li>Einfügen und Löschen von Elementen</li>
</ul>

![Datenstrukturen](/Datenstrukturen/Datenstrukturen.png)

<h2>Arten von Datenstrukturen</h2>

<h3>1. Lineare Datenstrukturen</h3>
<ul>
  <li>Elemente sind <strong>sequenziell</strong> angeordnet.</li>
  <li>Beispiele: <code>Array</code>, <code>Stack</code>, <code>Queue</code>, <code>Linked List</code>.</li>
  <li><strong>Statisch:</strong> Größe fix (z. B. Array).<br>
      <strong>Dynamisch:</strong> Größe veränderbar (z. B. Liste, Stack, Queue).</li>
  <li>Nachteil: Zugriff auf einzelne Elemente meist nur sequentiell → bei großen Datenmengen langsam.</li>
</ul>

![Lineare](/Datenstrukturen/Lineare.png)

<h3>2. Hashbasierte Datenstrukturen</h3>
<ul>
  <li>Verwenden eine <strong>Hashfunktion</strong>, um Schlüssel-Wert-Paare zu speichern.</li>
  <li>Zugriff über Schlüssel statt über Index.</li>
  <li>Beispiele: <code>Hashtable</code>, <code>HashMap</code>.</li>
  <li><strong>Vorteil:</strong> Sehr schnelle Suche.</li>
  <li><strong>Nachteil:</strong> Kollisionen möglich (mehrere Schlüssel erzeugen gleichen Hashwert).</li>

  ![Hashbasierte](/Datenstrukturen/Hashbasierte.png)

</ul>

<h3>3. Bäume</h3>
<ul>
  <li>Hierarchische Struktur mit <strong>Knoten</strong> und <strong>Kanten</strong>.</li>
  <li>Typen: <code>Binärbaum</code>, <code>Suchbaum</code>, <code>Heap</code>.</li>
  <li>Schnelle Suche und Sortierung möglich.</li>
  <li>Einsatzgebiete: KI, Sprachverarbeitung, Bildverarbeitung.</li>
</ul>

  ![Bäume](/Datenstrukturen/Bäume.png)


<h3>4. Graphen</h3>
<ul>
  <li>Nichtlineare Struktur aus <strong>Knoten</strong> und <strong>Kanten</strong>.</li>
  <li>Dient zur Darstellung von Beziehungen zwischen Elementen.</li>
  <li>Beispiele: <code>Adjazenzmatrix</code>, <code>Inzidenzmatrix</code>, <code>Adjazenzliste</code>.</li>
  <li>Wichtig für Netzwerke, Pfadsuche, Datenbanken.</li>
</ul>

![Graphen](/Datenstrukturen/Graphen.png)

<h3>5. Mengen (Sets)</h3>
<ul>
  <li>Ungeordnete Sammlung eindeutiger Elemente (kein Duplikat).</li>
  <li>Typische Operationen: Vereinigung, Schnitt, Differenz.</li>
  <li>In Programmiersprachen meist als <code>Set</code> implementiert.</li>
</ul>

<h2>Typische Datenstrukturen im Detail</h2>

<h3>(1) Array (Feld)</h3>
<ul>
  <li>Speichert mehrere Elemente desselben Typs.</li>
  <li>Zugriff über Index, feste Größe.</li>
  <li>Formen: eindimensional, zweidimensional (Matrix).</li>
</ul>

![Array](/Datenstrukturen/Array.png)

<table>
  <tr><th>Vorteile</th><th>Nachteile</th></tr>
  <tr>
    <td>
      <ul>
        <li>schnelles Lesen und Schreiben der Werte von Elementen, da direkt über die Indizes zugegriffen werden kann</li>
        <li>einfache Datenstruktur</li>
        <li>in allen gängigen Programmiersprachen standardmäßig integriert</li>
      </ul>
    </td>
    <td>
      <ul>
        <li>Größe muss im Vorfeld festgelegt werden</li>
        <li>in der Regel kein Hinzufügen von neuen Elementen möglich</li>
        <li>bei dynamischen Arrays hoher Aufwand beim Hinzufügen; Löschen wird in der Regel oft vermieden</li>
        <li>teilweise aufwendiges Suchen, weil im ungünstigsten Fall alle Elemente durchlaufen werden müssen</li>
      </ul>
    </td>
  </tr>
</table>



<h3>(2) Verkettete Listen</h3>
<ul>
  <li>Dynamische Größe, Elemente (Knoten) zeigen aufeinander.</li>
  <li>Typen: einfach oder doppelt verkettet.</li>
</ul>

![Liste](/Datenstrukturen/Liste1.png)

![Liste](/Datenstrukturen/Liste.png)


### Vor- und Nachteile — Einfach verkettete Liste

| Vorteile | Nachteile |
|---|---|
| Elemente können sehr schnell am Anfang der Liste eingefügt werden. | Lesen, Schreiben und Suchen sind bei großen Datenmengen zeitintensiv; Aufwand hängt von der Position ab (O(n)). |
| Einfügen und Löschen sind schnell, sofern die Position bekannt ist (z. B. am Listenanfang). | Kein direkter Indexzugriff — nur sequentieller Zugriff. |
| Größe muss im Vorfeld nicht bekannt sein; dynamische Anpassung möglich. | Zusätzlicher Speicherbedarf für Zeiger in jedem Knoten. |
| Geringer Verwaltungsaufwand für einfache Operationen. | Komplexere Verwaltung bei Operationen, die Zugriff auf den Vorgänger erfordern (z. B. Löschen eines mittleren Elements). |

<h3>(3) Stapel (Stack) &amp; Warteschlange (Queue)</h3>
<ul>
  <li><strong>Stack:</strong> LIFO-Prinzip (Last In First Out).</li>
  <li><strong>Queue:</strong> FIFO-Prinzip (First In First Out).</li>
  <li>Realisierung oft über Listen.</li>
  <li>Anwendungen:
    <ul>
      <li>Stack: Funktionsaufrufe, Rücksprungadressen.</li>
      <li>Queue: Ereignisverwaltung (GUI, Druckerwarteschlange).</li>
    </ul>
  </li>
</ul>

![LIFO](/Datenstrukturen/LIFO.png)

![FIFO](/Datenstrukturen/FIFO.png)

<h3>(4) Hashtabelle</h3>
<ul>
  <li>Schlüssel-Wert-Paare, Position über Hashfunktion berechnet.</li>
  <li>Kollisionen müssen behandelt werden (z. B. durch Verkettung).</li>
</ul>

<table>
<tr><th>Vorteile</th><th>Nachteile</th></tr>
<tr><td>schnelles Suchen in großen Datenmengen möglich</td><td>mögliche Kollisionen bei der Erzeugung von Hashwerten</td></tr>
<tr><td>schneller Lese- und Schreibzugriff, vor allem im Vergleich mit Bäumen </td><td>mit steigendendem Füllgrad steigt die Wahrscheinlichkeit einer Kollision</td></tr>
<tr><td>weniger Speicherplatzverbrauch im Vergleich zu
Arrays</td><td></td><tr>
</table>

![Hashtabelle](/Datenstrukturen/Hashtabelle.png)


<h2>Prüfungsrelevante Aussagen</h2>
<ul>
  <li>✅ Eine Datenstruktur ist ein geordnetes Objekt zur Datenverwaltung.</li>
  <li>✅ Klassische Arrays haben feste Größe.</li>
  <li>✅ Bäume sind dynamische Strukturen.</li>
  <li>✅ Sets erlauben Mengenoperationen.</li>
  <li>✅ Hashtabellen ermöglichen schnelle Suche, aber Kollisionen können auftreten.</li>
  <li>✅ Stacks arbeiten nach LIFO, Queues nach FIFO.</li>
  <li>❌ Bäume sind keine linearen Strukturen.</li>
  <li>❌ Einfach verkettete Listen besitzen keinen Zeiger auf Vorgänger.</li>
</ul>

<h2>Merksatz</h2>
<blockquote>
Die Wahl der richtigen Datenstruktur bestimmt maßgeblich die Effizienz, Lesbarkeit und Erweiterbarkeit eines Programms.
</blockquote>

</body>
</html>
