# 2.2.1 Grundlegende Datenstrukturen beschreiben [Seite: 136] 

**Kernaussage:** **Datenstrukturen** organisieren und verwalten Daten so, dass **Lesen/Schreiben**, **Suchen** sowie **Einfügen/Löschen** effizient erfolgen. Die Auswahl richtet sich nach **Struktur** und **Menge** der Daten sowie den **Verwaltungsanforderungen**; nicht jede Struktur passt zu jedem Zweck. Effizienz ergibt sich aus **Speicherbedarf** und **Ausführungszeit** der Operationen. 

## Definition

Eine **Datenstruktur** ist ein Objekt (Container), in dem Daten gleichen oder unterschiedlichen **Datentypen** in einer festgelegten **Struktur** angeordnet und verwaltet werden. 

## Grundlegende Operationen

* **Lesen/Schreiben** einzelner Elemente
* **Suchen** eines bestimmten Elements
* **Einfügen/Löschen** von Elementen
  Diese Operationen können je nach Struktur unterschiedlich effizient sein (z. B. schnelles Lesen/Schreiben, aber aufwendiges Einfügen/Löschen – oder umgekehrt). 

## Effizienzkriterien (Trade-offs)

* **Zeitkomplexität** der Basisoperationen vs. **Speicherbedarf**.
* Häufige Muster: schnelle **Direktzugriffe** bei festen Indizes, aber teure Größenänderungen; dynamische Strukturen mit flexibler Größe, aber sequentiellem Zugriff. 

## Arten von Datenstrukturen

### Lineare Datenstrukturen

* **Array (Feld):** statisch (feste Größe), indexbasierter Zugriff; sequentielles Durchlaufen; dynamische Arrays existieren, Einfügen kann aber ineffizient sein.

* **Stack (LIFO)** und **Queue (FIFO):** spezielle lineare Abläufe (z. B. Aufruf-Stack, Ereigniswarteschlangen).
* **Verkettete Liste (Linked List):** dynamisch wachsend/schrumpfend; Zugriff sequentiell, daher langsamer als Array.
  Lineare Strukturen werden **sequenziell** angeordnet und lassen sich vollständig durchlaufen. 

### Hashbasierte Datenstrukturen

* **Hashtabelle/Hash-Map:** Zugriff über **Schlüssel** statt Index; schneller Zugriff/Modifikation über **Hashfunktion**; Nachteil: **Kollisionen** müssen behandelt werden. (Nicht linear.) 

### Nichtlineare Strukturen (Überblick)

* **Bäume** (z. B. **Binärbaum**, **binärer Suchbaum**, **Heap**): hierarchische Anordnung, effiziente Suche in geordneten Varianten.
* **Graphen:** **Knoten–Kanten**-Modelle für Beziehungen jenseits linear/baumartig; Repräsentationen wie **Adjazenzmatrix**/**-liste**.
* **Mengen (Set):** ungeordnete Sammlung **eindeutiger** Elemente, mit **Vereinigung**, **Schnitt**, **Differenz**.

## Auswahlleitfaden (aus dem Abschnitt abgeleitet)

* Anforderungen klären: **Datenart/-menge**, **Zugriffsmuster** (mehr Lesen/Schreiben vs. häufiges Einfügen/Löschen), **Suchanforderungen**.
* **Lineare** Strukturen für sequenzielle Abläufe und einfache Indizes.
* **Hash**-Strukturen für schnellen Zugriff über **Schlüssel** bei großen Datenmengen (Kollisionsmanagement beachten).
* **Bäume/Graphen** für hierarchische bzw. komplex vernetzte Daten; **Mengen** zur Sicherung von **Eindeutigkeit**. 

## Merksätze

* **Arrays:** schnell im Zugriff, unflexibel in der Größe.
* **Listen:** flexibel in der Größe, Zugriff sequentiell.
* **Stacks/Queues:** LIFO/FIFO für Steuerungs- und Ereignisflüsse.
* **Hashtabellen:** Schlüssel-basiert schnell, **Kollisionen** im Blick behalten.
* **Bäume/Graphen/Mengen:** für Hierarchien, Beziehungen und Eindeutigkeit.

---

## [Nächstes Thema:](./2.2.2_Datenstrukturen_bedarfsgerecht_auswaehlen.md)