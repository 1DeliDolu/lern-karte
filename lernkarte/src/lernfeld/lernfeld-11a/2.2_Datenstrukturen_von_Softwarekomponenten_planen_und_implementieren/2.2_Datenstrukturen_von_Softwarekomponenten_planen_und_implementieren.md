# 2.2 Datenstrukturen von Softwarekomponenten planen und implementieren [Seite: 136] 

**Kernaussage:** Die Auswahl geeigneter **Datenstrukturen** ist für Funktionalität, Speicherbedarf und Laufzeit zentraler als die konkrete Algorithmik. Entscheidend sind Datenart, -menge, Änderungsdynamik sowie Zugriffs-/Suchanforderungen. Ziel ist eine effiziente Verwaltung (Einfügen, Löschen, Lesen/Schreiben, Suchen) bei minimaler **Zeit-** und **Speicherkomplexität**.

## Grundbegriffe und Grundoperationen

* **Datenstruktur:** Objekt/Container, das Werte (ggf. unterschiedlicher **Datentypen**) nach einer festgelegten Struktur speichert und verwaltet.
* Grundoperationen: **Einfügen**, **Löschen**, **Lesen/Schreiben**, **Suchen**.
* Effizienzkriterien: **Speicherplatz** vs. **Operationenlaufzeit** (Trade-off).

## Arten von Datenstrukturen

* **Lineare** Strukturen: **Array**, **Stack**, **Queue**, **(verkettete) Liste**; statisch (feste Größe, z. B. **Array**) vs. dynamisch (wachsend/schrumpfend, z. B. **Liste**, **Queue**).
* **Hashbasierte** Strukturen: **Hashtabelle** (**Schlüssel–Wert**), schneller Direktzugriff via **Hashfunktion**, aber mögliche **Kollisionen**.
* **Bäume** (z. B. **Binärbaum**, **Suchbaum**, **Heap**): hierarchische Organisation, schnelle Suche/Einfügeoperationen in geordneten Varianten.
* **Graphen**: generische **Knoten–Kanten**-Modelle für Beziehungsdaten.
* **Mengen** (**Set**): ungeordnete, eindeutige Elemente; Mengenoperationen (**Vereinigung**, **Schnitt**, **Differenz**).

## Typische Vertreter – Eigenschaften (kompakt)

### **Array**

* Konzept: Indexbasierter, zusammenhängender Speicher (**1D/2D**).
* Zugriff **O(1)**; Größe i. d. R. fest.
* Vorteil: sehr schnelles **Lesen/Schreiben**, einfache Struktur.
* Nachteil: **Größenanpassung** teuer/unmöglich; sequentielle **Suche** oft **O(n)**.

### **Einfach/Doppelt verkettete Liste**

* Konzept: **Knoten** mit Wert (+ Verweis auf **Nachfolger**, ggf. **Vorgänger**).
* Vorteil: schnelles **Einfügen/Löschen** an bekannten Positionen; dynamisch.
* Nachteil: **Zugriff/Suche** sequentiell **O(n)**; doppelt verkettet = mehr Speicher/Zeigerpflege.

### **Stack / Queue**

* **Stack (LIFO)**: z. B. **Aufruf-Stack**; Zugriff nur oben.
* **Queue (FIFO)**: Ereignis-/Auftragsverarbeitung.
* Praktisch oft als Listenvarianten; Fokus auf **push/pop** bzw. **enqueue/dequeue**.

### **Hashtabelle**

* Konzept: **Key → Index** via **Hashfunktion**; **Schlüssel–Wert-Paare**.
* Vorteil: typ. **O(1)** für Suche/Update bei moderater **Lastfaktor**.
* Nachteil: **Kollisionen** erfordern Strategien; Performance sinkt bei hohem Füllgrad.

## Auswahl passend zur Anforderung (Fallbeispiele)

* **Sitzplatzbelegung (Theater):** feste Zeilen/Sitze, primär Lesen/Schreiben ⇒ **zweidimensionales Array**.
* **Getränkebestellungen (Restaurant):** unbekannte, dynamische Anzahl; FIFO-Abarbeitung ⇒ **Queue** (alternativ **doppelt verkettete Liste**).
* **RAL-Farben (Grafikmodul):** viele Einträge, seltener Update, schneller Zugriff per **Schlüssel** (Farbnummer) ⇒ **Hashtabelle** mit Farb-Objekten.

## Python – grundlegende Datenstrukturen & Operationen

* **Liste**: heterogen, dynamisch; zentrale Methoden: **append**, **extend**, **insert**, **pop**, **remove**, **reverse**, **sort**; unterstützt **mehrdimensionale** Strukturen (Liste von Listen).
* **Dictionary**: **Key–Value** mit schnellem Zugriff: **d[k]**, **d[k]=v**, **del d[k]**; Utilities: **len**, **clear**, **copy**, **pop**, **setdefault**, **update**.
* **Tupel**: geordnete, **unveränderliche** Sequenz.
* **Set**: ungeordnet, **eindeutige** Elemente; Mengenoperationen.

## Java – grundlegende Datenstrukturen & Collection-Framework

* **Array**: fester Typ/feste Größe; mehrdimensional möglich; Länge via **length**.
* **ArrayList** (`java.util`): dynamisches Feld; Kernmethoden: **add**, **remove(index)**, **get**, **set**, **size**, **clear**, **clone**, **isEmpty**.
* **HashMap**: **put(key,value)**, **get**, **replace**, **remove**; dynamisch, unsortiert.
* **HashSet**: Menge eindeutiger Elemente auf **Hash**-Basis.
* Hierarchie (Auszug): **Collection**/**Map** mit **List**, **Set**, Klassen wie **ArrayList**, **LinkedList**, **HashSet**, **HashMap**, **TreeMap**, **LinkedHashMap**.

## Didaktische Leitlinien aus dem Abschnitt

* Auswahl immer an **Anforderungsspezifikation** ausrichten (Datenmenge, Änderungsrate, Zugriffsmuster).
* **Trade-offs** bewusst abwägen (Speicher vs. Zeit; Update- vs. Lese-lastig).
* Sprachen bieten **fertige Implementierungen** – eigene Implementationen schulen das Verständnis, werden aber in der Praxis selten benötigt.

## Merksätze (Kurzcheck)

* **Arrays**: schnell zugreifen, schwer wachsen.
* **Listen**: flexibel wachsen, langsamer zugreifen.
* **Stacks/Queues**: LIFO/FIFO für Prozess-/Auftragsflüsse.
* **Hashtabellen**: schnell über **Schlüssel**, aber **Kollisionen** managen.
* **Sets**: Einzigartigkeit garantieren, Mengenlogik nutzen.

---

## [Nächstes Thema:](./2.2.1_Grundlegende_Datenstrukturen_beschreiben.md)