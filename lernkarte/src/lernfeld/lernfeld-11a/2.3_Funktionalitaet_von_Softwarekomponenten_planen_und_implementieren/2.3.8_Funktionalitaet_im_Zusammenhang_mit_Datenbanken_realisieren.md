# 2.3.8 Funktionalität im Zusammenhang mit Datenbanken realisieren [Seite: 192]

**Kernaussage:** Anwendungen binden **Datenbanken** über standardisierte **Schnittstellen** an, stellen **Verbindungen** her und führen **SQL**-Anweisungen aus. Neben herstellerspezifischen APIs existieren allgemeine Zugriffsarten (**ODBC**, **JDBC**, **ADO.NET**); zusätzlich sind **Transaktionen**, **Stored Procedures** und **Trigger** zentrale Bausteine einer robusten Datenbankfunktionalität. 

## Datenbankschnittstellen und Architektur

* **ODBC**: Standardisierte, DBMS-unabhängige API; Trennung über **ODBC-Treiber**.
* **JDBC**: Java-API für relationale DBs; benötigt **DB-spezifische Treiber**; Ergebnisse kommen z. B. als **ResultSet** zurück; Bridge zu ODBC möglich.
* **ADO.NET**: .NET-Datenzugriff mit Komponenten zum Lesen/Schreiben von DB-Daten. 

## Verbindungen und Ressourcenmanagement

* **Ziel:** Verbindung herstellen, nutzen, sauber schließen.
* **Connection Pooling**: Pool offener **Verbindungen** zur Effizienzsteigerung; sinnvoll je nach Last/Ressourcenlage.
* **Beispiel (JDBC)**: Treiber laden, `DriverManager.getConnection(...)`, anschließend `close()` im `finally`-Block. 

## SQL in Anwendungen ausführen

* **DML/DDL** via `executeUpdate(...)`: **INSERT**, **UPDATE**, **DELETE**, **CREATE/ALTER/DROP TABLE**.
* **SELECT** via `executeQuery(...)` → **ResultSet** weiterverarbeiten.
* SQL-Konzepte im Kontext: **Aggregatfunktionen** (MIN, MAX, AVG, SUM, COUNT), **Unterabfragen**, **UNION**, **IN/EXISTS/ANY/ALL**. 

## Transaktionen (ACID-relevante Steuerung)

* **Zweck:** Entweder **alles** oder **nichts** ausführen; **Konsistenz** sichern, konkurrierende Zugriffe koordinieren.
* **Kommandos:** `START TRANSACTION`/`BEGIN`, `COMMIT`, `ROLLBACK`.
* **Beispiele:** Mehrere Anweisungen ausführen und dauerhaft speichern (**COMMIT**) bzw. Änderungen zu Testzwecken zurücknehmen (**ROLLBACK**). 

### Transaktionen mit JDBC

* **Standard:** **Auto-Commit** (jede Anweisung = eigene Transaktion).
* **Gebündelt arbeiten:** `setAutoCommit(false)` → mehrere Statements, dann `commit()`; bei Fehlern `rollback()`.
* **Praxis:** Nutzung von **PreparedStatement** für sichere, performante Ausführung. 

## Stored Procedures und Trigger

* **Stored Procedures:** In der DB gespeicherte **Prozeduren**; enthalten **SQL** und **Ablaufsteuerung**; Vorteile: **Performance**, **Sicherheit**.

  * **Syntax (Beispiel):** `CREATE PROCEDURE ... AS ...`, **Aufruf:** `EXECUTE ...`, **Löschen:** `DROP PROCEDURE ...`.
* **Trigger:** Von der **Datenbank automatisch** ausgelöste, ereignisgebundene Prozeduren.

## Implementierungsschritte (didaktisch)

1. **Schnittstelle wählen** (z. B. **JDBC** in Java) und passenden **Treiber** einbinden. 
2. **Verbindung aufbauen** (URL, Benutzer, Passwort), **Pooling** ggf. konfigurieren. 
3. **SQL ausführen**: DML/DDL mit `executeUpdate(...)`, Abfragen mit `executeQuery(...)` und **ResultSet** verarbeiten. 
4. **Transaktionen steuern**: Auto-Commit prüfen/abschalten, konsistente Blöcke mit **COMMIT/ROLLBACK** sichern. 
5. **Erweiterungen**: **Stored Procedures**/ **Trigger** nutzen, um Logik in die DB zu verlagern. 

## Kompetenzcheck (aus dem Abschnitt)

* Aussagen zu **ODBC/JDBC**, **Connection Pool**, **Transaktionen/Auto-Commit**, **Stored Procedures/Trigger** bewerten (Arbeitsbuch-Bezug). 

## Merkkasten – Schlüsselbegriffe

* **ODBC**, **JDBC**, **ADO.NET**, **Connection Pool(ing)**, **SQL**, **ResultSet**, **Aggregatfunktion**, **Unterabfrage**, **UNION**, **Transaktion**, **COMMIT**, **ROLLBACK**, **Auto-Commit**, **PreparedStatement**, **Stored Procedure**, **Trigger**.
