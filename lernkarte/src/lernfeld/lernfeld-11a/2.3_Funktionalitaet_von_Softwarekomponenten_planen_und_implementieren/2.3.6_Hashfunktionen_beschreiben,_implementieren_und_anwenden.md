# 2.3.6 Hashfunktionen beschreiben, implementieren und anwenden [Seite: 182]

**Kernaussage:** **Hashfunktionen** bilden Eingaben beliebiger Länge auf **Hashwerte** fester Länge ab, typischerweise als **hexadezimale** Zeichenfolge. Sie sind **nicht umkehrbar** und dienen u. a. der **Integritätssicherung**; sie sind **keine Verschlüsselungsverfahren**. Verbreitete Verfahren sind z. B. **SHA-256/224**, **SHA-512/384**; **MD5** gilt als **unsicher**. 

## Begriffe und Zielsetzung

* **Hashalgorithmus:** Verfahren zur Reduktion einer Zeichenfolge auf eine **feste Länge**; das Ergebnis ist der **Hashwert**. **Kollisionen** (verschiedene Eingaben liefern denselben Hash) sind prinzipiell möglich; gute Hashalgorithmen minimieren deren Auftreten. **Hexadezimale** Ausgabe ist üblich. 
* **Einsatzfelder:** **Prüfsummen**, **digitale Signaturen**, **Hashtabellen**, **Blockchain**-Transaktionen (z. B. Bitcoin). 

## Eigenschaften guter Hashfunktionen

* **Unidirektional:** Aus dem Hashwert darf der Ursprung **nicht** effizient rekonstruierbar sein.
* **Kollisionssicherheit:** Unterschiedliche Eingaben liefern **unterschiedliche** Hashwerte (bei kryptographischen Hashfunktionen); Kollisionen sollten extrem **unwahrscheinlich** sein.
* **Schnell:** Hashwerte müssen **effizient** berechnet werden. 

## Didaktisches Beispiel: einfacher Hashalgorithmus

**Idee:** Der Text wird blockweise (je **4 Zeichen**) verarbeitet. Pro Zeichen wird der **ASCII-Code** mit einem **Multiplikator** (Block-intern: 1, 64, 4096, 262144) multipliziert und zur **Summe** addiert. Zum Schluss wird die Summe per **Modulo** auf die gewünschte **Ziffernanzahl** begrenzt (z. B. `10^digits`). Ein möglicher **Überlauf** bei großen Summen ist unkritisch, da nur ein Hashwert gefordert ist. 

**Umsetzungshinweise (sprachneutral → Python/Java):**

* **Blockbildung & Multiplikator** wie oben; **ASCII** via `ord(...)` (**Python**) bzw. `charAt(...)` (**Java**).
* **Begrenzung** auf `digits` Ziffern per **Modulo** (`10^digits` → `math.pow`/**`Math.pow`**).
* Ergebnis als **Ganzzahl** (optional später in **Hex** umwandeln). 

## Kryptographische Hashes in der Praxis: **SHA-256**

* **SHA-256** erzeugt einen **256-Bit**-Hash mit fester Länge; weit verbreitet und gilt als **sehr sicher**. Für dasselbe Passwort liefern Python- und Java-Implementierungen **identische Hashwerte**. 
* **Python:** `hashlib.sha256(...).hexdigest()` für Hex-Ausgabe.
* **Java:** `MessageDigest.getInstance("SHA-256")` → `digest(...)`, anschließend **Hex-Konvertierung**. 

## Anwendung und Abgrenzung

* **Passwortspeicherung:** Nur **Hashwerte** persistieren (kein Klartext).
* **Integritätsprüfung:** Dateien/Nachrichten per **Prüfsumme** verifizieren.
* **Datenstrukturen:** **Hashtabellen** nutzen Hashfunktionen; **Kollisionen** sind zu behandeln.

## Kompetenzcheck (aus dem Abschnitt)

* Erweitern Sie den einfachen Algorithmus: **dezimalen Hashwert → hexadezimaler** Hashwert als String (Planung per **Struktogramm**, danach Implementierung).
* Vertiefung: **Lernsituation 3 – Aufgaben 8–9** (Passwort-Hashing, englischer Fachtext). 

## Merkkasten – Schlüsselbegriffe

* **Hashfunktion**, **Hashalgorithmus**, **Hashwert**, **Kollision**, **Kollisionsresistenz**, **Unidirektionalität**, **Prüfsumme**, **digitale Signatur**, **Hashtabelle**, **SHA-256**, **MD5 (unsicher)**, **`hashlib`**, **`MessageDigest`**.

---

## [Nächstes Thema](./2.3.7_JSON-Dateien_im-_und_exportieren_und_Webservices_nutzen.md)