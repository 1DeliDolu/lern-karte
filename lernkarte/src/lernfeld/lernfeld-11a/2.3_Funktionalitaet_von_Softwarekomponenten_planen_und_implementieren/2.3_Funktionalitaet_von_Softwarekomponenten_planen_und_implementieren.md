# 2.3 Funktionalität von Softwarekomponenten planen und implementieren [Seite: 159]

Kurzüberblick: Dieser Abschnitt behandelt, wie Softwarefunktionalität aus Anforderungen abgeleitet, als **Algorithmus** modelliert, in Code (z. B. **Python**, **Java**) umgesetzt und mit gängigen Verfahren (z. B. **Rekursion**, **Sortieren**, **Komprimierung**, **Verschlüsselung**, **Datei-/Web-Schnittstellen**, **Datenbanken**) realisiert wird. Zentrale Beispiele beziehen sich auf das Projekt „**Yachthafen Resort**“.

## Ziele und Vorgehen

* Funktionalität gedanklich präzisieren (**Modellierung** mit **PAP**, **Struktogramm**, **Pseudocode**), dann sauber implementieren. Beispiel: Belegungsberechnung aus einem **Boolean-Array** im „Yachthafen Resort“. 
* Geeignete Realisierungsverfahren auswählen und korrekt anwenden: **rekursiv** vs. **iterativ**, effiziente **Sortieralgorithmen**, verlustfreie/-behaftete **Komprimierung**, sichere **Verschlüsselung/Hashing**, robuste **Schnittstellen** (**JSON**, **REST**), performanter **Datenbankzugriff** (**ODBC/JDBC**, **SQL**, **Transaktionen**, **Stored Procedures**, **Trigger**).

---

## 2.3.1 Algorithmen entwerfen und implementieren

**Kernidee:** Anforderungen → **Algorithmus** → Modell (PAP/Struktogramm/**Pseudocode**) → Code.
**Beispiel („Yachthafen Resort“):** Auslastung in % aus **liegeplatzbelegung** (Boolean-Array) ermitteln; Modellierung und Umsetzung in Python/Java.

**Typische Modellierungsmittel**

* **Programmablaufplan (PAP)** für Kontrollfluss
* **Struktogramm** zur blockstrukturierten Darstellung
* **Pseudocode** für sprachunabhängige Logikbeschreibung 

---

## 2.3.2 Rekursive Algorithmen umsetzen

**Merkmale:** wiederholte Anwendung gleicher Schritte auf veränderte Daten; zwingende **Abbruchbedingung**; Ergebnis einer Rekursion dient als Eingabe der nächsten. **Vorsicht:** **Stack Overflow** bei fehlendem Abbruch. **Trade-off:** rekursiv oft eleganter, iterativ meist speicher-/laufzeitökonomischer. **Beispiel:** Dezimal-→-Dual-Umrechnung per Division.

---

## 2.3.3 Sortierverfahren beschreiben, implementieren und anwenden

**Ziel:** Daten einer linearen Struktur (z. B. **Array**) nach Kriterium effizient ordnen; Laufzeit abhängig vom Ausgangszustand (**Best/Average/Worst Case**). **Beispiele:** **Bubblesort**, **Insertionsort**, **Mergesort**, **Quicksort**, **Heapsort**, **Selectionsort**, **Shellsort**. Zudem: Nutzung integrierter Sortierfunktionen in Python/Java (auf-/absteigend).

---

## 2.3.4 Komprimierungsverfahren beschreiben, implementieren und anwenden

**Begriffe:** **Komprimierungsalgorithmus** (reduziert Datenmenge), **verlustfrei** vs. **verlustbehaftet**.
**Beispiele:**

* **RLE (Lauflängenkodierung):** einfache, verlustfreie Methode für viele Wiederholungen; Python/Java-Umsetzung demonstriert. 
* **ZIP/Deflate:** Bibliotheksgestützte Dateikomprimierung; Beispiel: Bilddateien des „Yachthafen Resort“ komprimieren.

---

## 2.3.5 Verschlüsselungsverfahren beschreiben, implementieren und anwenden

**Ziel:** **Vertraulichkeit** sichern; Überblick über **Verschlüsselungsalgorithmen** und praxisnahe **Hashing**-Beispiele.
**Beispiel:** **SHA-256**-Hash von Passwörtern in Python/Java (Byte-Hash → hexadezimaler Hash). 

---

## 2.3.7 JSON-Dateien im-/exportieren und Webservices nutzen

**Datei-/Schnittstellenbasis:** Austausch über **CSV**, **XML**, **JSON**; in Python mit Paket **json** (dumps/loads); in Java z. B. **javax.json** (separat einbinden).
**Webservices (REST):** Zugriff per **HTTP-Methoden** **GET**, **POST**, **PUT**, **DELETE**; Auswertung von **Statuscodes**; Beispiel: Abruf von Wetterdaten (OpenWeatherMap) via **requests** in Python mit API-Key.

---

## 2.3.8 Funktionalität im Zusammenhang mit Datenbanken realisieren

**Schnittstellen:** **ODBC** (standardisierte, DBMS-unabhängige API), **JDBC** (Java-Schnittstelle) zur Kommunikation und **SQL**-Ausführung aus Programmen. 
**SQL in Programmen:** Ausführen von **DDL/DML** (z. B. `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`) und `SELECT` (Rückgabe als **ResultSet**). 
**Transaktionen:** Start (**BEGIN/START TRANSACTION**), Abschluss (**COMMIT**) oder Rücknahme (**ROLLBACK**); Beispielsequenzen für atomare Änderungen. 
**Stored Procedures & Trigger:** Prozeduren mit SQL/Steuerlogik; **Trigger** als von der DB selbst ausgelöste Spezialfälle. 

---

## Merksätze (kompakt)

* **Modellieren vor Codieren**: Klarer **PAP/Struktogramm/Pseudocode** spart Fehler im Code. 
* **Rekursion** nur mit sauberer **Abbruchbedingung**; iterativ prüfen. 
* **Sortieren**: Algorithmuswahl nach Datenlage; integrierte Sorts nutzen, wenn möglich. 
* **Komprimierung** & **Verschlüsselung/Hashing**: passende Verfahren und Bibliotheken wählen.
* **Schnittstellen zuerst denken**: **JSON/REST** für Datenaustausch; **ODBC/JDBC/SQL** für persistente Daten inkl. **Transaktionen**.

---

## Beispielhafte Prüfungs-/Praxisaufgaben (aus dem Abschnitt)

* Boolean-Belegung aggregieren; Monatsauswertung (min/max/Ø, Schwellwerte). 
* Rekursiven Ansatz zu einem iterativen Algorithmus kontrastieren. 
* **Bubblesort** erweitern (Tausch-Zähler); weitere Sortierverfahren implementieren. 
* **RLE** kodieren/dekodieren; **ZIP**-Komprimierung programmieren.
* **SHA-256**-Hash erzeugen und formatieren. 
* **JSON** importieren/exportieren; **REST**-API konsumieren (HTTP-Methoden/Statuscodes). 
* **SQL** aus Code ausführen; **Transaktionen**, **Stored Procedures**, **Trigger** einsetzen.

---

## [Nächstes](./2.3.1_Algorithmen_entwerfen_und_implementieren.md)