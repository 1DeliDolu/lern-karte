# 2.3.3 Sortierverfahren beschreiben, implementieren und anwenden [Seite: 167]

**Kernaussage:** Ein **Sortieralgorithmus** ordnet Elemente einer linearen Datenstruktur (z. B. **Array**) nach einem Kriterium (auf- oder absteigend). Für große Datenmengen sind effiziente Verfahren entscheidend; moderne Sprachen liefern zwar **Bibliotheksfunktionen**, dennoch fördert das Implementieren einfacher Verfahren das Verständnis. **Laufzeiten** werden als **Best/Average/Worst Case** betrachtet. 

## Begriff und Ziel

* **Eingabe:** Feld/Liste mit Werten und ggf. **Sortierkriterium**.
* **Ausgabe:** Dasselbe Feld/Liste in sortierter Reihenfolge.
* **Ziel:** Korrekte Ordnung bei möglichst geringer **Zeit-/Speicherkomplexität**; Aufwand hängt vom Ausgangszustand (vor-/teil-/unsortiert) ab.
* **Beispiele:** **Bubblesort**, **Heapsort**, **Insertionsort**, **Mergesort**, **Quicksort**, **Selectionsort**, **Shellsort**.

## Beispielverfahren: **Bubblesort**

**Idee:** In mehreren **Pässen** benachbarte Elemente vergleichen und bei falscher Reihenfolge **tauschen**; das größte Element „blubbert“ pro Pass ans Ende.
**Optimierung:** Wenn in einem Pass kein **Tausch** stattfindet, ist die Folge sortiert → **früher Abbruch**.
**Pseudocode (sprachneutral):**

1. Wiederhole (äußerer Pass)
2. `tauschte ← false`
3. Für `i` von `0` bis `n-2-PassIndex`: wenn `a[i] > a[i+1]`, **tausche** und `tauschte ← true`
4. Wenn `tauschte == false`: **Beenden**
5. Ende
   **Hinweis:** Umsetzung wird exemplarisch in **Python**/**Java** mit Flag für „Tausch erfolgt“ gezeigt. 

## Vorgehen beim Implementieren

* **Struktur:** Zwei **Schleifen** (äußere Pässe, innere Vergleiche), **Tausch** per temporärer Variable.
* **Korrektheit:** Früher Abbruch reduziert unnötige Vergleiche bei (teil)sortierten Daten.
* **Spracheigenheiten:** Indexgrenzen, **In-Place**-Sortierung, Datentypen (z. B. **int**, **String**).

## Vorimplementierte Sortierfunktionen nutzen

* **Python:** `list.sort()` (aufsteigend), optional `reverse=True` für absteigend.
* **Java:** `Arrays.sort(array)` (aufsteigend für primitive/Comparable), für absteigend z. B. `Arrays.sort(objArray, Collections.reverseOrder())`.
* **Praxis:** Für Produktionscode bevorzugt **Bibliotheksfunktionen** (stabil, optimiert); manuelle Implementierungen dienen dem Verständnis und Übungen. 

## Anwendung und Bewertung

* **Didaktik:** Einfachverfahren wie **Bubblesort** eignen sich zum Erlernen von **Vergleich**, **Tausch**, **Schleifen**, **Abbruchbedingungen**.
* **Effizienz:** Für große Datenmengen besser **Mergesort/Quicksort/Heapsort** (über Bibliotheken verfügbar).
* **Fallstricke:** Überflüssige Vergleiche ohne Frühabbruch; falsche Indexbereiche.

## Kompetenzcheck (aus dem Abschnitt)

* **Aufgabe:** **Bubblesort** erweitern – **Anzahl der Tausche** mitzählen und ausgeben.
* **Weiterführung:** Weitere **einfache Sortieralgorithmen** entwerfen und implementieren (Prüfungsvorbereitung). 

## Merkkasten – Schlüsselbegriffe

* **Sortieralgorithmus**, **Array/Liste**, **Best/Average/Worst Case**, **Vergleich**, **Tausch**, **Pass**, **Frühabbruch**, **Bubblesort**, **Bibliotheksfunktion**, **`list.sort()`**, **`Arrays.sort()`**, **`Collections.reverseOrder()`**.



---

## [Nächstes Thema](./2.3.4_Komprimierungsverfahren_beschreiben,_implementieren_und_anwenden.md)