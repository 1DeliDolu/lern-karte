# 2.3.4 Komprimierungsverfahren beschreiben, implementieren und anwenden [Seite: 171]

**Kernaussage:** **Komprimierungsalgorithmen** reduzieren digitale Datenmengen, um **Speicherplatz** zu sparen und **Übertragungszeiten** zu verkürzen. Man unterscheidet **verlustfreie** (alle Originalinformationen rekonstruierbar) und **verlustbehaftete** Verfahren (nicht alle Informationen rekonstruierbar). Typische Beispiele sind **JPEG**, **GIF**, **TIFF**, **MP3**, **WMA**, **WMV**, **MPEG**. In der Praxis stehen viele Verfahren als **Bibliotheksfunktionen** zur Verfügung. 

## Grundbegriffe und Ziele

* **Komprimierungsalgorithmus:** Verfahren zur **Datenreduktion**; entfernt **Redundanzen** und speichert Informationen **effizienter**.
* **Verlustfrei** vs. **verlustbehaftet:** Rekonstruktion vollständig möglich vs. gezielter Informationsabwurf (z. B. außerhalb menschlicher Wahrnehmung).
* **Praktischer Nutzen:** Geringere **Dateigröße** und **schnellere Übertragung**; Auswahl abhängig von **Datenart** (Grafik/Audio/Video/Text). 

## (1) Lauflängenkodierung (**RLE**)

**Prinzip:** Folgen identischer Werte werden durch **Anzahl** + **Wert** ersetzt → besonders effizient bei **vielen Wiederholungen** (z. B. wenige Farben, große Flächen). Bei stark wechselnden Werten kann sich die Datenmenge **nicht verringern** oder sogar **vergrößern**; RLE dient heute oft als **Vorkodierung** (u. a. in **JPEG**, **TIFF**). 

### Beispielrechnung (Rastergrafik)

* Unkomprimiert: `10 × 10 × 3 Byte = 300 Byte`.
* RLE-kodiert (idealisiert): `38 × 1 Byte (Anzahl) + 38 × 3 Byte (RGB) = 152 Byte`.
* Verhältnis: `152 / 300 ≈ 50,66 %` → etwa **halbe Größe**. 

### Algorithmusidee (Textbeispiel)

* Durchlaufe den **Eingabetext**, zähle die **Lauflänge** identischer aufeinanderfolgender Zeichen und hänge `Anzahl + Zeichen` an das **Ergebnis**.
* Umsetzung nutzt zwei **kopfgesteuerte Schleifen** (äußere Position, innere Zählung). 

### Pseudocode (sprachneutral)

* `i ← 0; encoded ← ""`
* solange `i < len(text)`:

  * `count ← 1; c ← text[i]; j ← i`
  * solange `j < len(text)-1` und `text[j] == text[j+1]`: `count++`, `j++`
  * `encoded ← encoded + count + c`
  * `i ← j + 1`
* **Rückgabe:** `encoded`. 

### Implementierungshinweise (Python/Java)

* **Python:** Zeichenkettenaufbau mit **`str(count)`** und **Indexierung** wie oben.
* **Java:** Verwendung von **`charAt`**, **`Integer.toString(count)`**, sorgfältige **Indexgrenzen**.
* Beide Varianten folgen dem Pseudocode **1:1**. 

## (2) Dateien zu **ZIP**-Archiven komprimieren (inkl. **Deflate**)

**ZIP** ist ein **Containerformat** für verlustfreie Komprimierung (u. a. **Deflate**). Vorgehen: Datei(en) sammeln, komprimiert in ein **.zip** schreiben. Hinweis: Manche Formate (z. B. **JPEG**) sind **bereits komprimiert** → geringe Zusatzreduktion. 

### Umsetzung (Überblick)

* **Python:** Modul **`zipfile`**; ZIP-Datei im Modus **`'w'`** mit **`ZIP_DEFLATED`** öffnen, **`write()`** aufrufen; Größen vor/nachher ausgeben.
* **Java:** Paket **`java.util.zip`**; **`ZipOutputStream`**, **`ZipEntry`**, Eingabe-/Ausgabestreams, **`write(bytes, …)`**; Größen vor/nachher prüfen. 

### Projektbezug

* Beispiel „**Yachthafen Resort**“: **Bilddateien** der Liegeplätze paketieren/komprimieren (z. B. zur Archivierung oder Übertragung). 

## Kompetenzcheck (aus dem Abschnitt)

* Entwickeln Sie einen **Dekompressionsalgorithmus** für RLE (Struktogramm → Implementierung).
* Bearbeiten Sie ergänzend die **Lernsituation 3, Aufgabe 5** im Arbeitsbuch. 

## Merkkasten – Schlüsselbegriffe

* **Komprimierung**, **Redundanz**, **verlustfrei**, **verlustbehaftet**, **RLE**, **Lauflänge**, **Deflate**, **ZIP-Archiv**, **Bibliotheksfunktion**, **Stream**.

---

## [Nächstes Thema:](./2.3.5_Verschluesselungsverfahren_beschreiben,_implementieren_und_anwenden.md)