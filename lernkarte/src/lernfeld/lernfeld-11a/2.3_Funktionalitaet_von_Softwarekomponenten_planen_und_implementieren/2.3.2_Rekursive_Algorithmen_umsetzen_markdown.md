# 2.3.2 Rekursive Algorithmen umsetzen

<html>
<head>
<style>
h1, h2, h3 {
  font-weight: 700;
  color: #000;
  margin-top: 1.2em;
}
h1 { font-size: 1.8em; border-bottom: 2px solid #000; padding-bottom: 6px; }
h2 { font-size: 1.4em; margin-top: 1.2em; }
ul { margin-left: 20px; }
code {
  background: #f3f3f3;
  padding: 2px 5px;
  border-radius: 4px;
  font-size: 0.95em;
}
blockquote {
  border-left: 4px solid #000;
  padding-left: 10px;
  color: #333;
  margin: 10px 0;
}
pre {
  background: #f8f8f8;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid #ddd;
  overflow-x: auto;
}
</style>
</head>
<body>


<h2>Grundprinzip der Rekursion</h2>
<ul>
  <li><strong>Rekursion</strong> bedeutet, dass sich eine Funktion <em>selbst aufruft</em>, um ein Problem schrittweise zu lösen.</li>
  <li>Sie eignet sich besonders, wenn sich ein komplexes Problem auf ein kleineres Teilproblem derselben Art zurückführen lässt.</li>
  <li>Wichtige Voraussetzung: Es muss eine <strong>Abbruchbedingung</strong> geben, damit der Algorithmus endet.</li>
</ul>

<h3>Merkmale rekursiver Algorithmen</h3>
<ul>
  <li>Der Algorithmus wird mehrfach ausgeführt.</li>
  <li>Die Eingangsdaten ändern sich bei jedem Aufruf (z. B. kleiner werdende Zahl).</li>
  <li>Die Logik des Algorithmus bleibt gleich.</li>
  <li>Es existiert eine <strong>Abbruchbedingung</strong>, z. B. wenn ein Wert 0 erreicht ist.</li>
</ul>

<h2>Beispiel: Umwandlung einer Dezimalzahl in eine Dualzahl</h2>
<p>Die Umwandlung erfolgt nach der <strong>Divisionsmethode</strong>:</p>
<ol>
  <li>Die Zahl wird durch 2 geteilt → ganzzahliges Ergebnis <code>n</code>.</li>
  <li>Der Rest der Division (<code>r</code>) ist entweder 0 oder 1.</li>
  <li>Das Ergebnis wird erneut mit <code>n</code> berechnet, bis <code>n = 0</code> ist.</li>
  <li>Alle Reste werden in umgekehrter Reihenfolge zusammengefügt → Dualzahl.</li>
</ol>

<h3>Prüfung der Rekursionseignung</h3>
<ul>
  <li>Mehrfachausführung nötig → ✅</li>
  <li>Daten ändern sich (Zahl wird kleiner) → ✅</li>
  <li>Algorithmus bleibt gleich → ✅</li>
  <li>Abbruchbedingung bei Zahl = 0 → ✅</li>
</ul>

<h2>Rekursiver Algorithmus in Python</h2>
<pre><code class="language-python">
def decimal_to_binary(number):
    if number < 0:
        return "Es muss eine positive ganze Zahl sein!"
    n = number // 2        # Ganzzahldivision
    r = number % 2         # Rest (0 oder 1)
    if n == 0:             # Abbruchbedingung
        return str(r)
    else:
        return decimal_to_binary(n) + str(r)  # Rekursiver Aufruf

number = int(input("Geben Sie eine positive ganze Zahl ein: "))
print(decimal_to_binary(number)) </code></pre>

<h2>Rekursiver Algorithmus in Java</h2>
<pre><code class="language-java">
import java.util.Scanner;

public class Programm {
public static void main(String[] args) {
System.out.print("Geben Sie eine positive ganze Zahl ein: ");
Scanner sc = new Scanner(System.in);
int number = sc.nextInt();
System.out.println(decimalToBinary(number));
}

```
static String decimalToBinary(int number) {
    if (number < 0) {
        return "Es muss eine positive ganze Zahl sein!";
    }
    int n = number / 2;   // Ganzzahldivision
    int r = number % 2;   // Rest (0 oder 1)
    if (n == 0) {         // Abbruchbedingung
        return Integer.toString(r);
    } else {
        return decimalToBinary(n) + Integer.toString(r); // Rekursion
    }
}
```

} </code></pre>

<h2>Iterative vs. Rekursive Lösung</h2>
<table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse; width:100%;">
  <tr style="background:#eee;">
    <th>Aspekt</th>
    <th>Iterativ</th>
    <th>Rekursiv</th>
  </tr>
  <tr>
    <td>Umsetzung</td>
    <td>Mit Schleifen (z. B. <code>while</code>, <code>for</code>)</td>
    <td>Mit Selbstaufrufen</td>
  </tr>
  <tr>
    <td>Effizienz</td>
    <td>Schneller, weniger Speicherverbrauch</td>
    <td>Langsamer, nutzt Stack-Speicher</td>
  </tr>
  <tr>
    <td>Code-Lesbarkeit</td>
    <td>Oft komplexer</td>
    <td>Eleganter, kürzer</td>
  </tr>
  <tr>
    <td>Gefahr</td>
    <td>Endlosschleifen</td>
    <td><strong>Stack Overflow</strong> bei fehlender Abbruchbedingung</td>
  </tr>
</table>

<h2>Beispiel: Summe der Zahlen von 0 bis n</h2>
<p><strong>Iterative Variante:</strong></p>
<pre><code class="language-python">
def summe_iterativ(n):
    summe = 0
    i = 1
    while i <= n:
        summe += i
        i += 1
    return summe
</code></pre>

<p><strong>Rekursive Variante:</strong></p>
<pre><code class="language-python">
def summe_rekursiv(n):
    if n == 0:
        return 0
    else:
        return n + summe_rekursiv(n - 1)
</code></pre>

<p><strong>Schreibtischtest (n = 3):</strong></p>
<blockquote>
summe_rekursiv(3) → 3 + summe_rekursiv(2)  
summe_rekursiv(2) → 2 + summe_rekursiv(1)  
summe_rekursiv(1) → 1 + summe_rekursiv(0)  
summe_rekursiv(0) → 0 (Abbruchbedingung)  
➡ Ergebnis: 3 + 2 + 1 + 0 = <strong>6</strong>
</blockquote>

<h2>Prüfungsfokus</h2>
<ul>
  <li>Funktionsweise und Aufbau rekursiver Algorithmen erklären können.</li>
  <li>Abbruchbedingung korrekt identifizieren und implementieren.</li>
  <li>Rekursive und iterative Varianten unterscheiden.</li>
  <li>Einfache Rekursionen (z. B. Fakultät, Summe, Potenzierung, Umwandlung) umsetzen.</li>
</ul>

</body>
</html>
