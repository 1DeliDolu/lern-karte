# 2.3.2 Rekursive Algorithmen umsetzen [Seite: 164]

**Kernaussage:** **Rekursion** reduziert ein komplexes Problem schrittweise auf kleinere Teilprobleme. Rekursive Verfahren sind sinnvoll, wenn ein Algorithmus wiederholt ausgeführt wird, sich die Eingabedaten dabei ändern, der Verfahrensablauf gleich bleibt und eine klare **Abbruchbedingung** existiert. Unendliche Rekursionen sind möglich, aber hier nicht Gegenstand. 

## Merkmale rekursiv geeigneter Algorithmen

* Mehrfache Ausführung desselben **Algorithmus**.
* Pro Durchlauf veränderte **Eingabedaten**.
* Unveränderter **Ablauf** (gleiche Logik).
* Vorhandene **Abbruchbedingung** zur Terminierung. 

## Rekursiver Algorithmus – Funktionsweise

* Eine **Funktion** ruft sich selbst auf; das **Ergebnis** einer Rekursion dient als **Eingabe** für die nächste.
* Zur Umsetzung wird eine Funktion mit **Parameter(n)** und **Rückgabewert** definiert, die sich bis zur **Abbruchbedingung** selbst aufruft. 

## Beispiel: Dezimalzahl → Dualzahl (Divisionsmethode)

* Iteratives Prinzip: Ganzzahldivision durch 2; **Rest** 0/1 notieren; mit dem **Quotienten** fortfahren, bis 0 erreicht ist; Reste von unten nach oben ergeben die **Binärzahl** (z. B. 10 → 1010₂).
* Rekursive Eignung:

  * Mehrfache Ausführung? **Ja**.
  * Daten ändern sich? **Ja** (zahl → zahl//2).
  * Ablauf gleich? **Ja**.
  * Abbruchbedingung? **Ja** (zahl == 0).
* Umsetzung: Rekursive Funktion (Python/Java) mit **Ganzzahldivision**, **Restbildung** und **Basisfall**. 

## Umsetzungshinweise (sprachunabhängig)

* **Basisfall** zuerst definieren (z. B. „zahl == 0“).
* Pro Rekursionsschritt Eingabe **reduzieren** (z. B. `n = n // 2`).
* **Rückgabewert** korrekt zusammensetzen (z. B. Präfix/Suffix des Teil-Ergebnisses).
* In Python/Java auf **Ganzzahldivision**, **Datentypen** und **Zeichenketten**-Konkat. achten. 

## Rekursion vs. Iteration

* Jede rekursive Lösung ist auch **iterativ** darstellbar.
* **Iteration**: meist effizienter, geringerer **Speicherbedarf**.
* **Rekursion**: oft **eleganter** und **übersichtlicher**, weniger Hilfsvariablen.
* Achtung **Stack Overflow**: Jeder Aufruf belegt **Stack**-Speicher; ohne korrekte **Abbruchbedingung** droht Überlauf/Programmabbruch. 

## Kompetenzcheck (aus dem Abschnitt)

* Gegeben: Iterativer Algorithmus zur **Summenbildung** `0..n`.
* Aufgabe: **Rekursiv** formulieren, als **Struktogramm** darstellen, **Schreibtischtest** für `n=3`, dann implementieren. 

## Merkkasten – Schlüsselbegriffe

* **Rekursion**, **Abbruchbedingung**, **Basisfall**, **rekursiver Aufruf**, **Quotient/Rest**, **Ganzzahldivision**, **Call-Stack/Stack Overflow**, **Iteration**, **Struktogramm**.

---

## [Nächstes Thema:](./2.3.3_Sortierverfahren_beschreiben,_implementieren_und_anwenden.md)