# 2.3.6 Hashfunktionen beschreiben, implementieren und anwenden

<html>
<head>
<style>
h1, h2, h3 {
  border-bottom: 2px solid #444;
  padding-bottom: 4px;
  margin-top: 30px;
}
code, pre {
  background: #f4f4f4;
  padding: 6px 10px;
  border-radius: 6px;
  font-family: "Consolas", monospace;
  color: #222;
}
ul {
  list-style-type: square;
  margin-left: 20px;
}
blockquote {
  border-left: 4px solid #888;
  padding-left: 10px;
  color: #333;
  font-style: italic;
}
table {
  border-collapse: collapse;
  width: 100%;
  margin: 10px 0;
}
th, td {
  border: 1px solid #ddd;
  padding: 8px;
}
th {
  background-color: #f0f0f0;
}
</style>
</head>
<body>


<h2>Grundlagen der Hashfunktionen</h2>
<ul>
  <li><strong>Einsatzgebiet:</strong> Informationssicherheit (Integritätssicherung, Passwortspeicherung, digitale Signaturen, Blockchain).</li>
  <li>Hashfunktionen erzeugen aus Eingaben <strong>fester Länge</strong> (Hashwert).</li>
  <li>Im Gegensatz zur Verschlüsselung sind Hashwerte <strong>nicht rückrechenbar</strong>.</li>
  <li>Hashfunktionen sind daher keine Verschlüsselungsverfahren, werden aber in der Kryptographie genutzt.</li>
</ul>

<h2>Eigenschaften guter Hashalgorithmen</h2>
<table>
  <tr><th>Eigenschaft</th><th>Beschreibung</th></tr>
  <tr><td><strong>Unidirektional</strong></td><td>Nur in eine Richtung berechenbar (Hash → nicht zurückführbar).</td></tr>
  <tr><td><strong>Kollisionssicher</strong></td><td>Unterschiedliche Eingaben führen zu unterschiedlichen Hashwerten.</td></tr>
  <tr><td><strong>Schnell</strong></td><td>Effiziente Berechnung auch bei großen Datenmengen.</td></tr>
</table>

<blockquote>
  Achtung: Veraltete Hashfunktionen wie <strong>MD5</strong> gelten als unsicher, da Kollisionen nachgewiesen wurden.
</blockquote>

<h2>Einsatzgebiete</h2>
<ul>
  <li>Integritätsprüfung von Dateien</li>
  <li>Passwort-Hashing (z. B. in Datenbanken)</li>
  <li>Digitale Signaturen</li>
  <li>Blockchain (z. B. Bitcoin-Transaktionen)</li>
</ul>

<h2>Einfacher Beispiel-Hashalgorithmus</h2>
<ul>
  <li>Eingabe: beliebige Zeichenkette und gewünschte Länge des Hashwertes.</li>
  <li>Verarbeitung in Blöcken zu vier Zeichen.</li>
  <li>ASCII-Werte werden mit einem Multiplikator (<code>mul</code>) multipliziert, der sich je Zeichen ändert (×64).</li>
  <li>Summe aller Werte ergibt den Roh-Hashwert.</li>
  <li>Durch Modulo wird der Hashwert auf eine feste Länge begrenzt.</li>
</ul>

<h3>Beispiel</h3>
<pre><code>Eingabe: "passwort", Länge: 6
→ Hashwert: 506791
</code></pre>

<h3>Java-Implementierung</h3>
<pre><code>static long calculateHashvalue(String s, int digits) {
    long sum = 0;
    long mul = 1;
    for (int i = 0; i < s.length(); i++) {
        if (i % 4 == 0) mul = 1;
        else mul *= 64;
        sum += s.charAt(i) * mul;
    }
    if (digits >= 1)
        sum = sum % (long) Math.pow(10, digits);
    return sum;
}
</code></pre>

<h3>Python-Implementierung</h3>
<pre><code>import math

def calculate_hashvalue(s, digits):
    total = 0
    mul = 1
    for i in range(len(s)):
        if i % 4 == 0:
            mul = 1
        else:
            mul *= 64
            total += ord(s[i]) * mul
        if digits >= 1:
            total = total % math.pow(10, digits)
    return int(total) </code></pre>

<h3>Erweiterung</h3>
<p>Die Dezimalwerte können durch Umwandlung in <strong>hexadezimale Hashwerte</strong> ergänzt werden, z. B. mit:</p>
<pre><code>hex(result)[2:]</code></pre>

<h2>Vorimplementierte Hashfunktionen: SHA-256</h2>
<ul>
  <li><strong>SHA-256</strong> (Secure Hash Algorithm) erzeugt 256-Bit-Hash.</li>
  <li>Sehr weit verbreitet in IT-Sicherheit und Blockchain.</li>
  <li>Ein Hashwert kann nicht auf den Originalwert zurückgeführt werden.</li>
</ul>

<h3>Python-Beispiel (SHA-256)</h3>
<pre><code>import hashlib

password = "Mein Passwort"
encoded = password.encode()
hash_value = hashlib.sha256(encoded)

print("Passwort:", password)
print("Hashwert:", hash_value.hexdigest()) </code></pre>

<h3>Java-Beispiel (SHA-256)</h3>
<pre>
<code>import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;

public class Program {
    public static void main(String[] args) {
    try {
        String password = "Mein Passwort";
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(password.getBytes(StandardCharsets.UTF_8));
        BigInteger no = new BigInteger(1, hash);
        String hashValue = no.toString(16);
        while (hashValue.length() < 64) hashValue = "0" + hashValue;
            System.out.println("Passwort: " + password);
            System.out.println("Hashwert: " + hashValue);
    } catch (Exception e) {
        e.printStackTrace();
    }
    }
} 
</code></pre>

<h2>Zusammenfassung – Prüfungsrelevant</h2>
<table>
  <tr><th>Aspekt</th><th>Beschreibung</th></tr>
  <tr><td>Hashfunktion</td><td>Verkürzt Eingaben auf fixe Länge, nicht rückrechenbar</td></tr>
  <tr><td>Kollision</td><td>Verschiedene Eingaben erzeugen gleichen Hash</td></tr>
  <tr><td>Wichtige Algorithmen</td><td>SHA-256, SHA-512, MD5 (unsicher)</td></tr>
  <tr><td>Verwendung</td><td>Passwortspeicherung, Blockchain, Prüfsummen</td></tr>
  <tr><td>Eigenschaften</td><td>Unidirektional, kollisionssicher, schnell</td></tr>
</table>

<h3>Kompetenzcheck</h3>
<ul>
  <li>Erweitere den Beispiel-Hashalgorithmus, sodass er hexadezimale Hashwerte ausgibt.</li>
  <li>Plane den Algorithmus in einem Struktogramm und implementiere ihn in Python oder Java.</li>
  <li>Bearbeite im Arbeitsbuch Lernsituation 3, Aufgaben 8 und 9 – Thema Passwort-Hashing.</li>
</ul>

</body>
</html>

