# 2.3.4 Komprimierungsverfahren beschreiben, implementieren und anwenden

<html>
<head>
<style>
h1, h2, h3 {
  font-weight: 700;
  color: #000;
  margin-top: 1.2em;
}
h1 { font-size: 1.8em; border-bottom: 2px solid #000; padding-bottom: 6px; }
h2 { font-size: 1.4em; margin-top: 1.2em; }
ul { margin-left: 20px; }
code {
  background: #f3f3f3;
  padding: 2px 5px;
  border-radius: 4px;
  font-size: 0.95em;
}
pre {
  background: #f8f8f8;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid #ddd;
  overflow-x: auto;
}
blockquote {
  border-left: 4px solid #000;
  padding-left: 10px;
  color: #333;
  margin: 10px 0;
}
table {
  border-collapse: collapse;
  width: 100%;
  margin-top: 10px;
}
th, td {
  border: 1px solid #ccc;
  padding: 6px 8px;
  text-align: left;
}
th {
  background-color: #eee;
}
</style>
</head>
<body>

<h1>2.3.4 Komprimierungsverfahren beschreiben, implementieren und anwenden</h1>

<h2>Grundlagen der Datenkompression</h2>
<ul>
  <li>Komprimierung reduziert die <strong>Datenmenge</strong>, um Speicherplatz zu sparen oder Übertragungszeiten zu verkürzen.</li>
  <li>Das Ziel ist, <strong>redundante Informationen</strong> zu entfernen oder effizienter zu speichern.</li>
  <li>Es wird zwischen zwei Arten unterschieden:
    <ul>
      <li><strong>Verlustfreie Komprimierung</strong>: Alle Originaldaten können wiederhergestellt werden (z. B. ZIP, PNG, RLE).</li>
      <li><strong>Verlustbehaftete Komprimierung</strong>: Nicht alle Daten werden wiederhergestellt (z. B. MP3, JPEG, MPEG).</li>
    </ul>
  </li>
</ul>

<h3>Typische Komprimierungsverfahren</h3>
<ul>
  <li><strong>JPEG, GIF, TIFF</strong> → Grafikkompression</li>
  <li><strong>MP3, WMA</strong> → Audiokompression</li>
  <li><strong>MPEG, WMV</strong> → Videokompression</li>
</ul>

<h2>Lauflängenkodierung (Run-Length Encoding, RLE)</h2>

<p>Die <strong>Lauflängenkodierung</strong> ist ein einfaches, verlustfreies Komprimierungsverfahren.  
Sie ersetzt aufeinanderfolgende gleiche Zeichen oder Werte durch die <em>Anzahl der Wiederholungen</em> und das <em>Zeichen</em>.</p>

<h3>Funktionsweise</h3>
<ul>
  <li>Geeignet für Daten mit vielen identischen Werten hintereinander (z. B. große Farbflächen in Grafiken).</li>
  <li>Beispiel:  
    <code>aaaaabbbcccccccdefff</code> → <code>5a3b7c1d1e3f</code>
  </li>
  <li>Enthält der Text viele wechselnde Zeichen, kann die Datenmenge größer werden.</li>
</ul>

<h3>Algorithmusbeschreibung</h3>
<ol>
  <li>Aktuelles Zeichen merken.</li>
  <li>Zählen, wie oft es hintereinander vorkommt.</li>
  <li>Beim ersten neuen Zeichen: Zähler und Zeichen im komprimierten Text speichern.</li>
  <li>Schleife wiederholen, bis Textende erreicht ist.</li>
</ol>

<h2>Implementierung: Lauflängenkodierung</h2>

<h3>Python</h3>
<pre><code class="language-python">
def run_length_encoding(text):
    encoded_text = ""
    i = 0
    while i < len(text):
        count = 1
        c = text[i]
        j = i
        while j < len(text) - 1:
            if text[j] == text[j + 1]:
                count += 1
                j += 1
            else:
                break
        encoded_text += str(count) + c
        i = j + 1
    return encoded_text

text = "aaaaabbbcccccccdefff"
encoded = run_length_encoding(text)
print(encoded)  # Ausgabe: 5a3b7c1d1e3f </code></pre>

<h3>Java</h3>
<pre><code class="language-java">
public class Program {
    public static void main(String[] args) {
        String text = "aaaaabbbcccccccdefff";
        String encoded = runLengthEncoding(text);
        System.out.println(encoded);
    }

```
static String runLengthEncoding(String text) {
    String encodedText = "";
    int i = 0;
    while (i < text.length()) {
        int count = 1;
        char c = text.charAt(i);
        int j = i;
        while (j < text.length() - 1) {
            if (text.charAt(j) == text.charAt(j + 1)) {
                count++;
                j++;
            } else break;
        }
        encodedText += Integer.toString(count) + c;
        i = j + 1;
    }
    return encodedText;
}
```

} </code></pre>

<h2>Komprimierung mit ZIP-Archiven</h2>

<h3>Deflate-Algorithmus</h3>
<ul>
  <li>Verlustfreier Komprimierungsalgorithmus, der im ZIP-Format verwendet wird.</li>
  <li>Er kombiniert <strong>Lauflängenkodierung</strong> und <strong>Huffman-Kodierung</strong> für effiziente Datenreduktion.</li>
  <li>Einsatzbeispiel: Komprimierung von Bilddateien im Projekt <em>„Yachthafen Resort“</em>.</li>
</ul>

<h3>Python-Beispiel mit ZIP</h3>
<pre><code class="language-python">
import os, zipfile

print(os.path.getsize("Liegeplatz.jpg"), "Byte")

with zipfile.ZipFile("liegeplatz.zip", "w", zipfile.ZIP_DEFLATED) as zipf:
zipf.write("Liegeplatz.jpg")

print("ZIP-Datei wurde erstellt.")
print(os.path.getsize("liegeplatz.zip"), "Byte") </code></pre>

<h3>Java-Beispiel mit ZIP</h3>
<pre><code class="language-java">
import java.io.*;
import java.util.zip.*;

public class Program {
public static void main(String[] args) {
try {
File file = new File("Liegeplatz.jpg");
System.out.println(file.length() + " Byte");

```
        FileOutputStream fos = new FileOutputStream("Liegeplatz.zip");
        ZipOutputStream zos = new ZipOutputStream(fos);
        FileInputStream fis = new FileInputStream(file);
        
        ZipEntry entry = new ZipEntry(file.getName());
        zos.putNextEntry(entry);
        
        byte[] buffer = new byte[1024];
        int length;
        while ((length = fis.read(buffer)) >= 0) {
            zos.write(buffer, 0, length);
        }
        
        zos.close();
        fis.close();
        fos.close();
        
        System.out.println("ZIP-Datei wurde erstellt.");
        File zipFile = new File("Liegeplatz.zip");
        System.out.println(zipFile.length() + " Byte");
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

} </code></pre>

<h2>Entpackung (Dekompression) – Kompetenzcheck</h2>
<p>Aufgabe: Entwickeln Sie einen Algorithmus, der aus dem komprimierten Text wieder den Originaltext erzeugt.</p>

<h3>Beispiel in Python</h3>
<pre><code class="language-python">
def run_length_decoding(encoded):
    decoded = ""
    count = ""
    for ch in encoded:
        if ch.isdigit():
            count += ch
        else:
            decoded += ch * int(count)
            count = ""
    return decoded

print(run_length_decoding("5a3b7c1d1e3f"))

# Ausgabe: aaaaabbbcccccccdefff

</code></pre>

<h2>Prüfungsfokus</h2>
<ul>
  <li>Unterschied zwischen verlustfreier und verlustbehafteter Komprimierung erklären.</li>
  <li>Lauflängenkodierung beschreiben, analysieren und programmieren können.</li>
  <li>Bibliotheken zur Komprimierung (z. B. <code>zipfile</code>, <code>java.util.zip</code>) praktisch einsetzen.</li>
  <li>Rekonstruktion (Dekompression) logisch nachvollziehen können.</li>
</ul>

</body>
</html>


