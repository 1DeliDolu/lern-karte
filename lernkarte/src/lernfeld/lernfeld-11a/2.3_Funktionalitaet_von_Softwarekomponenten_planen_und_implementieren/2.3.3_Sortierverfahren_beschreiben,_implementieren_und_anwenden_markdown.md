# 2.3.3 Sortierverfahren beschreiben, implementieren und anwenden

<html>
<head>
<style>
h1, h2, h3 {
  font-weight: 700;
  color: #000;
  margin-top: 1.2em;
}
h1 { font-size: 1.8em; border-bottom: 2px solid #000; padding-bottom: 6px; }
h2 { font-size: 1.4em; margin-top: 1.2em; }
ul { margin-left: 20px; }
code {
  background: #f3f3f3;
  padding: 2px 5px;
  border-radius: 4px;
  font-size: 0.95em;
}
pre {
  background: #f8f8f8;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid #ddd;
  overflow-x: auto;
}
blockquote {
  border-left: 4px solid #000;
  padding-left: 10px;
  color: #333;
  margin: 10px 0;
}
table {
  border-collapse: collapse;
  width: 100%;
  margin-top: 10px;
}
th, td {
  border: 1px solid #ccc;
  padding: 6px 8px;
  text-align: left;
}
th {
  background-color: #eee;
}
</style>
</head>
<body>


<h2>Grundlagen der Sortierung</h2>
<ul>
  <li>Sortieralgorithmen ordnen die Elemente einer <strong>linearen Datenstruktur</strong> (z. B. Array oder Liste) nach einem bestimmten Kriterium.</li>
  <li>Die Sortierung kann <strong>aufsteigend</strong> oder <strong>absteigend</strong> erfolgen.</li>
  <li>Ziel ist eine möglichst <strong>effiziente Sortierung</strong>, insbesondere bei großen Datenmengen.</li>
</ul>

<h3>Sortieralgorithmus – Definition</h3>
<p>Ein <strong>Sortieralgorithmus</strong> ist ein Verfahren, das die Reihenfolge von Elementen nach einem Vergleichskriterium verändert.</p>
<ul>
  <li><strong>Eingabe:</strong> unsortiertes Array</li>
  <li><strong>Ausgabe:</strong> sortiertes Array</li>
  <li><strong>Kriterien:</strong> numerisch, alphabetisch oder nach benutzerdefinierten Eigenschaften</li>
</ul>

<h3>Komplexität und Laufzeit</h3>
<p>Die Effizienz hängt stark vom Ausgangszustand der Daten ab:</p>
<ul>
  <li><strong>Best Case:</strong> Daten sind bereits sortiert → minimale Laufzeit</li>
  <li><strong>Average Case:</strong> durchschnittlicher Aufwand</li>
  <li><strong>Worst Case:</strong> Daten sind komplett unsortiert → maximale Laufzeit</li>
</ul>

<h2>Beispiele für Sortierverfahren</h2>
<ul>
  <li>Bubblesort</li>
  <li>Insertionsort</li>
  <li>Selectionsort</li>
  <li>Mergesort</li>
  <li>Quicksort</li>
  <li>Heapsort</li>
  <li>Shellsort</li>
</ul>

<h2>Beispiel: Bubblesort</h2>
<p>Der <strong>Bubblesort</strong> ist ein einfacher, aber ineffizienter Algorithmus (O(n²)), der Elemente durch wiederholtes Vergleichen und Tauschen sortiert.</p>

<h3>Funktionsweise</h3>
<ol>
  <li>Vergleiche benachbarte Elemente.</li>
  <li>Falls sie in falscher Reihenfolge stehen, tausche sie.</li>
  <li>Nach jedem Durchlauf steht das größte Element am Ende (wie eine „Blase“, engl. „bubble“).</li>
  <li>Wiederhole den Vorgang, bis kein Tausch mehr nötig ist.</li>
</ol>

<h3>Python-Implementierung</h3>
<pre><code class="language-python">
def bubbleSort(a):
    n = len(a)
    for i in range(0, n - 1):
        tausch = False
        for j in range(0, n - i - 1):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                tausch = True
        if not tausch:
            break

array = [65, 21, 42, 38, 55]
bubbleSort(array)
print("Sortiertes Feld:", array) </code></pre>

<h3>Java-Implementierung</h3>
<pre><code class="language-java">
public class Programm {
    public static void main(String[] args) {
        int[] array = {65, 21, 42, 38, 55};
        bubbleSort(array);
        System.out.println("Sortiertes Array:");
        for (int i : array)
            System.out.print(i + " ");
    }

```
static void bubbleSort(int[] a) {
    int n = a.length;
    for (int i = 0; i < n - 1; i++) {
        boolean tausch = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (a[j] > a[j + 1]) {
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
                tausch = true;
            }
        }
        if (!tausch)
            break;
    }
}
```

} </code></pre>

<h3>Beispiel: Sortierverlauf</h3>
<blockquote>
Eingangsarray: 65, 21, 42, 38, 55  
→ 1. Durchlauf: 21, 42, 38, 55, 65  
→ 2. Durchlauf: 21, 38, 42, 55, 65  
→ 3. Durchlauf: kein Tausch → Ende
</blockquote>

<h2>Erweiterung: Zählung der Tauschvorgänge</h2>

<h3>Python</h3>
<pre><code class="language-python">
def bubbleSort(a):
    n = len(a)
    tausch_count = 0
    for i in range(0, n - 1):
        tausch = False
        for j in range(0, n - i - 1):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                tausch = True
                tausch_count += 1
        if not tausch:
            break
    print("Anzahl der Tausche:", tausch_count)
</code></pre>

<h2>Vorgefertigte Sortierfunktionen</h2>
<p>Moderne Programmiersprachen bieten leistungsfähige, optimierte Sortierfunktionen an, die auf Algorithmen wie Quicksort oder TimSort basieren.</p>

<h3>Python</h3>
<pre><code class="language-python">
zahlen = [12, 4, -7, 71, 8, -4]
woerter = ["wald", "baum", "wasser", "meer"]

print(zahlen)
print(woerter)

zahlen.sort()                     # Aufsteigend sortieren
woerter.sort(reverse=True)        # Absteigend sortieren

print(zahlen)
print(woerter) </code></pre>

<h3>Java</h3>
<pre><code class="language-java">
import java.util.Arrays;
import java.util.Collections;

public class Program {
public static void main(String[] args) {
Integer[] zahlen = {12, 4, -7, 71, 8, -4};
String[] woerter = {"wald", "baum", "wasser", "meer"};

```
    System.out.println(Arrays.toString(zahlen));
    System.out.println(Arrays.toString(woerter));

    Arrays.sort(zahlen); // Aufsteigend
    Arrays.sort(woerter, Collections.reverseOrder()); // Absteigend

    System.out.println(Arrays.toString(zahlen));
    System.out.println(Arrays.toString(woerter));
}
```

} </code></pre>

<h2>Vergleich: Manuelle vs. eingebaute Sortierung</h2>
<table>
  <tr>
    <th>Kriterium</th>
    <th>Manueller Algorithmus</th>
    <th>Sortierfunktion</th>
  </tr>
  <tr>
    <td>Verständnis</td>
    <td>Fördert Grundverständnis für Algorithmen</td>
    <td>Einfach anwendbar</td>
  </tr>
  <tr>
    <td>Effizienz</td>
    <td>O(n²) bei einfachen Verfahren</td>
    <td>Optimierte Algorithmen (z. B. O(n log n))</td>
  </tr>
  <tr>
    <td>Fehleranfälligkeit</td>
    <td>Hoch bei eigener Implementierung</td>
    <td>Niedrig – getestet und stabil</td>
  </tr>
</table>

<h2>Prüfungsfokus</h2>
<ul>
  <li>Aufbau und Ablauf einfacher Sortieralgorithmen (z. B. Bubblesort) erläutern können.</li>
  <li>Sortierkriterien (aufsteigend/absteigend) in Programmen umsetzen.</li>
  <li>Laufzeitverhalten (Best/Average/Worst Case) erklären.</li>
  <li>Eingebaute Sortierfunktionen in Python (<code>.sort()</code>) und Java (<code>Arrays.sort()</code>) anwenden können.</li>
  <li>Verständnis für Effizienz und Speicherverhalten (O-Notation) zeigen.</li>
</ul>

</body>
</html>
