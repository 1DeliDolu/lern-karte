<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<style>
h1, h2, h3 {
  font-weight: 600;
  margin-top: 24px;
  margin-bottom: 12px;
}
ul {
  margin: 10px 0;
  padding-left: 20px;
}
code {
  background: #f4f4f4;
  padding: 2px 6px;
  border-radius: 4px;
}
blockquote {
  border-left: 4px solid #555;
  padding-left: 12px;
  color: #444;
  margin: 16px 0;
}
table {
  border-collapse: collapse;
  width: 100%;
  margin: 16px 0;
}
th, td {
  border: 1px solid #ccc;
  padding: 8px 12px;
  text-align: left;
}
th {
  background: #f0f0f0;
}
</style>
</head>
<body>

<h1>Modularisierung von Software</h1>

<h2>Grundidee</h2>
<ul>
  <li>Komplexe Softwaresysteme werden in kleinere, übersichtliche <b>Module</b> zerlegt.</li>
  <li>Jedes Modul ist eine funktional geschlossene Einheit mit klar definierten Schnittstellen.</li>
  <li>Module können wiederum andere Module (z. B. Klassen, Funktionen) enthalten.</li>
</ul>

<h2>Vorteile der Modularisierung</h2>
<ul>
  <li><b>Verständlichkeit:</b> Programme sind leichter nachvollziehbar.</li>
  <li><b>Wiederverwendbarkeit:</b> Module können in anderen Projekten eingesetzt werden.</li>
  <li><b>Austauschbarkeit:</b> Module können bei stabilen Schnittstellen problemlos ersetzt oder angepasst werden.</li>
  <li><b>Parallele Entwicklung:</b> Teams können unabhängig an verschiedenen Modulen arbeiten.</li>
</ul>

<h2>Ebenen der Modularisierung</h2>
<ul>
  <li><b>Methode/Funktion:</b> unterste Ebene, sollte nur eine Aufgabe erfüllen.</li>
  <li><b>Klasse:</b> Prototyp eines Moduls in der OOP, erfordert gutes Klassendesign.</li>
  <li><b>Softwarekomponente:</b> setzt sich aus Modulen (z. B. Klassen) zusammen und bündelt fachspezifische Dienste.</li>
</ul>

<h2>Beispiel: Yachthafen Resort Software</h2>
<p>Module wie:</p>
<ul>
  <li>Gebäudemanagement</li>
  <li>Eventmanagement</li>
  <li>Gastronomie</li>
  <li>Inventarmanagement</li>
  <li>Finanzen</li>
  <li>Marketing</li>
  <li>Personalmanagement</li>
  <li>Yachthafenmanagement</li>
</ul>

<h2>Wichtige Designregeln für Module</h2>

<table>
  <tr>
    <th>Prinzip</th>
    <th>Beschreibung</th>
  </tr>
  <tr>
    <td><b>Modulgeschlossenheit</b></td>
    <td>Modul erfüllt eine Aufgabe und ist in sich abgeschlossen. Kommunikation nur über definierte Schnittstellen.</td>
  </tr>
  <tr>
    <td><b>Modulbindung</b></td>
    <td>Starke innere Zusammenhänge zwischen Operationen und Daten im Modul (hohe Kohäsion).</td>
  </tr>
  <tr>
    <td><b>Modulkopplung</b></td>
    <td>Grad der Abhängigkeit zwischen Modulen. Soll möglichst gering sein.</td>
  </tr>
  <tr>
    <td><b>Minimalität der Schnittstelle</b></td>
    <td>Schnittstellen nur so umfangreich wie nötig, reduziert Kopplung und Testaufwand.</td>
  </tr>
  <tr>
    <td><b>Testbarkeit</b></td>
    <td>Module sollen isoliert testbar sein (Unit Tests, Modultests).</td>
  </tr>
</table>

<h2>Prüfungsrelevante Aussagen</h2>
<ul>
  <li>✔ Modularisierung ist ein zentraler Bestandteil moderner Softwareentwicklung.</li>
  <li>✔ Wiederverwendbarkeit von Quellcode wird durch Modularisierung gefördert.</li>
  <li>✘ Austauschbarkeit von Programmteilen wird <b>nicht erschwert</b>, sondern erleichtert.</li>
  <li>✔ Ein Modul ist eine funktional abgeschlossene Einheit.</li>
  <li>✔ Klassen eignen sich besonders gut zur Modularisierung.</li>
  <li>✘ Schnittstellen sollen <b>nicht umfangreich</b>, sondern minimal sein.</li>
  <li>✘ Unter Modulkopplung versteht man <b>nicht</b> interne Beziehungen, sondern Abhängigkeiten zwischen Modulen.</li>
</ul>

<blockquote>
<b>Merke:</b> Hohe Modulbindung + geringe Kopplung + kleine Schnittstellen = wartbare und flexible Softwarearchitektur.
</blockquote>

</body>
</html>
