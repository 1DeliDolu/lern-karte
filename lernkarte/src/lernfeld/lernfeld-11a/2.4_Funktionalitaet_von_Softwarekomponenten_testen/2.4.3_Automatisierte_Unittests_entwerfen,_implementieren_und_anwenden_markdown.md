# 2.4.3 Automatisierte Unittests entwerfen, implementieren und anwenden

<html>
<head>
<style>
h1, h2, h3 {
  color: #000;
  font-weight: 600;
  margin-top: 1.3em;
}
code {
  background: #f4f4f4;
  padding: 3px 6px;
  border-radius: 6px;
  font-size: 0.95em;
}
ul {
  margin-left: 20px;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 15px;
}
th, td {
  border: 1px solid #ccc;
  padding: 10px;
  text-align: left;
  vertical-align: top;
}
th {
  background: #f2f2f2;
}
blockquote {
  border-left: 4px solid #000;
  padding-left: 12px;
  color: #333;
  margin: 20px 0;
  font-style: italic;
}
</style>
</head>
<body>


<h2>Grundlagen</h2>
<p>
Unittests sind automatisierte <strong>Modultests</strong>, die einzelne Funktionen, Methoden oder Klassen einer Software überprüfen.  
Sie sind zentraler Bestandteil agiler Entwicklungsmethoden (z. B. Scrum), da sie häufig und automatisiert ausgeführt werden können.  
Dadurch wird eine hohe <strong>Codequalität</strong> und <strong>Fehlerfrüherkennung</strong> gewährleistet.
</p>

<h2>F.I.R.S.T.-Prinzipien guter Unittests</h2>
<ul>
  <li><strong>Fast:</strong> Tests sollen schnell ausführbar sein, um sie häufig ausführen zu können.</li>
  <li><strong>Independent:</strong> Jeder Test ist unabhängig von anderen Tests.</li>
  <li><strong>Repeatable:</strong> Gleiche Tests müssen immer dasselbe Ergebnis liefern.</li>
  <li><strong>Self-Validating:</strong> Test entscheidet selbst, ob er erfolgreich ist oder fehlschlägt.</li>
  <li><strong>Timely:</strong> Tests sollen <em>vor</em> der eigentlichen Implementierung geschrieben werden (TDD – Test Driven Development).</li>
</ul>

<h3>Weitere Qualitätsmerkmale</h3>
<ul>
  <li><strong>Begrenztheit:</strong> Nur eine Funktion oder Eigenschaft pro Test prüfen.</li>
  <li><strong>Verständlichkeit:</strong> Klarer, kurzer und lesbarer Testcode.</li>
  <li><strong>Wartbarkeit:</strong> Sauberer, gut strukturierter Testcode mit Konventionen.</li>
  <li><strong>Relevanz:</strong> Nur notwendige Programmteile testen.</li>
</ul>

<h2>JUnit (Java)</h2>
<p>
In Java werden Unittests meist mit dem Framework <strong>JUnit</strong> umgesetzt (aktuelle Version: JUnit 5 / Jupiter API).  
Tests liefern nur zwei Ergebnisse: <strong>grün</strong> (erfolgreich) oder <strong>rot</strong> (fehlgeschlagen).  
Fehler werden durch Exceptions signalisiert.
</p>

<h3>Wichtige JUnit-Annotationen</h3>
<table>
<tr><th>Annotation</th><th>Bedeutung</th></tr>
<tr><td><code>@Test</code></td><td>Markiert eine Methode als Testmethode.</td></tr>
<tr><td><code>@BeforeEach</code></td><td>Wird vor jedem Test ausgeführt.</td></tr>
<tr><td><code>@AfterEach</code></td><td>Wird nach jedem Test ausgeführt.</td></tr>
<tr><td><code>@BeforeAll</code></td><td>Wird einmalig vor allen Tests ausgeführt.</td></tr>
<tr><td><code>@AfterAll</code></td><td>Wird einmalig nach allen Tests ausgeführt.</td></tr>
<tr><td><code>@DisplayName</code></td><td>Zeigt benutzerdefinierten Testnamen an.</td></tr>
</table>

<h3>Wichtige JUnit-Assertions</h3>
<table>
<tr><th>Assertion</th><th>Funktion</th></tr>
<tr><td><code>assertTrue(expr)</code></td><td>Test besteht, wenn Ausdruck wahr ist.</td></tr>
<tr><td><code>assertFalse(expr)</code></td><td>Test besteht, wenn Ausdruck falsch ist.</td></tr>
<tr><td><code>assertEquals(expected, actual)</code></td><td>Vergleicht erwartetes mit tatsächlichem Ergebnis.</td></tr>
<tr><td><code>fail(message)</code></td><td>Lässt den Test manuell mit einer Fehlermeldung scheitern.</td></tr>
</table>

<h3>Beispiel: JUnit-Test</h3>
<pre><code>import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

class BeispielJUnitTest {
@Test
void testCalculateSum() {
int testVal1 = 3;
int testVal2 = 1;
int expectedResult = 4;
int result = calculateSum(testVal1, testVal2);
assertEquals(expectedResult, result, "Summe falsch");
}

```
public static int calculateSum(int x, int y) {
    return x + y;
}
```

} </code></pre>

<h2>Python Unittest-Modul</h2>
<p>
Python bietet das <strong>unittest</strong>-Modul (Teil der Standardbibliothek) zur Erstellung von automatisierten Tests.  
Das Modul basiert konzeptionell auf JUnit und verwendet die Klasse <code>unittest.TestCase</code>.
</p>

<h3>Ergebnisse eines Tests</h3>
<ul>
  <li><strong>OK:</strong> Alle Tests erfolgreich.</li>
  <li><strong>Failure:</strong> AssertionError (z. B. erwarteter Wert falsch).</li>
  <li><strong>Error:</strong> Andere Fehler (z. B. Syntaxfehler, Laufzeitfehler).</li>
</ul>

<h3>Wichtige Python-Assertions</h3>
<table>
<tr><th>Assertion</th><th>Bedeutung</th></tr>
<tr><td><code>assertEqual(a, b)</code></td><td>Test besteht, wenn a = b.</td></tr>
<tr><td><code>assertNotEqual(a, b)</code></td><td>Test besteht, wenn a ≠ b.</td></tr>
<tr><td><code>assertTrue(expr)</code></td><td>Test besteht, wenn Ausdruck wahr ist.</td></tr>
<tr><td><code>assertFalse(expr)</code></td><td>Test besteht, wenn Ausdruck falsch ist.</td></tr>
<tr><td><code>assertGreater(a, b)</code></td><td>Test besteht, wenn a > b.</td></tr>
<tr><td><code>assertLess(a, b)</code></td><td>Test besteht, wenn a &lt; b.</td></tr>
</table>

<h3>Beispiel: Python-Unittest</h3>
<pre><code>import unittest

class Example_Unittest(unittest.TestCase):
def test_calculate_cube_volume(self):
self.assertEqual(calculate_cube_volume(2), 8)
self.assertEqual(calculate_cube_volume(1), 1)
self.assertEqual(calculate_cube_volume(0), 0)
self.assertEqual(calculate_cube_volume(1.5), 3.375)

def calculate_cube_volume(x):
return x * x * x

# Ergebnis:

# Ran 1 test in 0.001s

# OK

</code></pre>

<h2>Vorteile automatisierter Unittests</h2>
<ul>
  <li>Früherkennung von Fehlern bei Codeänderungen.</li>
  <li>Unterstützung von <strong>Regressionstests</strong>.</li>
  <li>Erhöhte Softwarequalität und Wartbarkeit.</li>
  <li>Effizient bei kontinuierlicher Integration (CI/CD).</li>
</ul>

<h2>Kompetenzcheck – Richtige Aussagen</h2>
<ul>
  <li>a) ✅ Dynamische Testverfahren lassen sich gut automatisieren.</li>
  <li>b) ✅ Auch Unittests sollten wartbaren Code besitzen.</li>
  <li>c) ❌ Tests müssen unabhängig voneinander sein, nicht abhängig.</li>
  <li>d) ✅ Gute Unittests sind schnell auszuführen.</li>
  <li>e) ❌ Tests können in einer anderen Sprache geschrieben werden (nicht zwingend gleich).</li>
  <li>f) ❌ Das Framework heißt <strong>JUnit</strong>, nicht „Java-Unit“.</li>
  <li>g) ✅ Das Python-Modul heißt <strong>unittest</strong> und ist Teil der Standardbibliothek.</li>
</ul>

<blockquote>
Automatisierte Unittests sichern Codequalität, ermöglichen schnelle Fehlererkennung und sind Grundlage moderner Softwareentwicklung.
</blockquote>

</body>
</html>

