# 2.4.3 Automatisierte Unittests entwerfen, implementieren und anwenden [Seite: 206]

**Ziel:** **Modultests** vollständig **automatisieren**, um sie schnell, häufig und reproduzierbar auszuführen. In agilen Vorgehensmodellen (z. B. **Scrum**) ermöglicht dies eine wirksame **Qualitätssicherung** und die frühzeitige Erkennung von **Regressionsfehlern**: Test vor der Codeänderung ausführen, ändern, erneut testen, bei Fehlschlag korrigieren. 

## Merkmale guter Unittests (F.I.R.S.T.)

* **Fast**: schnelle Ausführung → häufige Läufe.
* **Independent**: Tests sind unabhängig, in beliebiger Reihenfolge/parallel ausführbar.
* **Repeatable**: gleiche Eingaben → gleiches Ergebnis.
* **Self-Validating**: eindeutiges **grün/rot** ohne manuelle Auswertung.
* **Timely**: idealerweise **vor** dem Produktivcode schreiben.


Weitere Kriterien: **Begrenztheit** (eine Eigenschaft pro Test), **Verständlichkeit**, **Wartbarkeit** (Codequalität, Konventionen), **Relevanz** (nur notwendige Teile testen).

## Unittests in Java (JUnit 5, Jupiter API)

* **Ergebnisse:** **grün** (erfolgreich) / **rot** (Fehlschlag). Fehlschläge durch **Failure** (z. B. `AssertionFailedError`) oder **Error** (andere Exceptions). 
* **Zentrale Annotations:** `@Test`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll`, `@DisplayName`, `@Timeout`.
* **Typische Assertions:** `assertTrue`, `assertFalse`, `assertEquals`, `fail`.
* **Beispielidee:** Methode `calculateSum(x, y)` wird mit vorbereiteten Testdaten ausgeführt; Erwartungswert via `assertEquals` geprüft; Test- und Produktionscode sind in der Praxis getrennt.

## Unittests in Python (`unittest`)

* **Ergebnisse:** **OK**, **Failure** (bei `AssertionError`), **Error** (sonstige Fehler).
* **Typische Assertions:** `assertEqual`, `assertNotEqual`, `assertTrue`, `assertFalse`, `assertGreater`, `assertLess`, u. a.
* **Beispielidee:** Funktionsprüfung (z. B. Volumenberechnung) inkl. **Grenzwerten**; Vergleich mit Erwartungswerten z. B. mit `assertAlmostEqual`; Tests i. d. R. getrennt vom Produktionscode. 

## Vorgehensschritte (kompakt)

1. **Testobjekt abgrenzen** (Klasse/Funktion) und **Akzeptanzkriterien**/Erwartungswerte festlegen. 
2. **Testfälle** aus Spezifikation/Code ableiten (z. B. Äquivalenzklassen, Grenzwerte, Abdeckungsziele).
3. **Automatisiert implementieren** (JUnit/unittest), **selbstvalidierend** gestalten.
4. **In den Workflow integrieren**: vor/nach Änderungen ausführen; bei **rot** Ursachen beheben (**Regressionstest**-Gedanke). 

## Kernaussagen

* **Automatisierte Unittests** sind eigenständige Programmteile für schnelle, wiederholbare Prüfungen und essenziell für agile **Qualitätssicherung**. 
* Gute Tests folgen **F.I.R.S.T.** und ergänzenden Kriterien (fokussiert, verständlich, wartbar, relevant). 
* Praxisnahe Umsetzung mit **JUnit 5 (Jupiter)** und **Python `unittest`** inkl. klarer Ergebnisanzeigen und Standard-Assertions.
