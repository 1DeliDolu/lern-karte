# 2.4 Funktionalität von Softwarekomponenten testen [Seite: 199]

Die **Funktionalitätsprüfung** ist Teil der **Qualitätssicherung** und fokussiert in diesem Abschnitt auf **Modultests/Unittests** als unterste **Teststufe**. In klassischen Modellen dienen sie primär der Fehlersuche; in **agilen Vorgehensmodellen** ermöglichen sie eine **iterative Entwicklung** – besonders durch **Automatisierung** des Testprozesses. Es wird die Auswahl geeigneter **Testverfahren**, die **Formulierung von Testfällen** sowie das **Entwerfen, Implementieren und Anwenden automatisierter Unittests** behandelt. 

## 2.4.1 Testverfahren auswählen

**Ziel:** Geeignetes Verfahren wählen, um Komponenten effizient zu prüfen. 

### Einordnung der Verfahren

* **Statische Verfahren** (z. B. Reviews): sinnvoll, aber für wiederholtes Testen oft zu aufwendig.
* **Dynamische Verfahren**: **Black-Box-Test** (spezifikationsorientiert) vs. **White-Box-Test** (struktur-/codeorientiert).
* **Testabdeckung**: Grad, zu dem Code/Daten/Anforderungen durch Tests abgedeckt sind. 

### Vor- und Nachteile (Auswahl)

* **Black-Box-Test**

  * **Pro:** unabhängig vom Code; Testfälle früh aus Spezifikationen ableitbar; tests aus **Anwendersicht**.
  * **Contra:** vollständige Ableitung aus unvollständiger Spezifikation schwierig; keine Garantie für vollständige Programmbedeckung. 
* **White-Box-Test**

  * **Pro:** interne Fehler lokalisierbar; hohe **Codeabdeckung** möglich; **Algorithmen** effektiv testbar.
  * **Contra:** stark codegekoppelt (wartungsintensiv nach Änderungen); hohe Abdeckung bei komplexem Code aufwendig. 

### Manuell vs. automatisiert

* **Manuelles Testen:** flexibel, aber personen- und zeitintensiv, wenig skalierbar.
* **Automatisiertes Testen:** Programm führt Tests selbständig aus; gut für **Regressionstests**; spart Zeit/Kosten, aber Initialaufwand hoch und nicht für alle Anwendungen geeignet. **Automatisierung ersetzt manuelle Tests nicht vollständig.**

## 2.4.2 Testfälle formulieren

**Ziel:** Aus Spezifikation bzw. Code **repräsentative Testdaten** auswählen, um hohe **Testabdeckung** zu erzielen. 

### Ableitungsquellen

* **Black-Box:** aus **Anforderungsspezifikation**, ohne Kenntnis der inneren Struktur.
* **White-Box:** aus **Programmlogik/Quellcode**. 

### Typische Verfahren

* **Äquivalenzklassenbildung** und **Grenzwertanalyse** (insb. für Black-Box).
* **Abdeckungsziele** im White-Box-Test:

  * **Anweisungsüberdeckung** (jede Anweisung mindestens einmal).
  * **Zweigüberdeckung** (alle Kanten/Entscheidungen mindestens einmal).
    Konkrete Beispiele zeigen, dass Zweigüberdeckung strengere Anforderungen stellt als reine Anweisungsüberdeckung.

## 2.4.3 Automatisierte Unittests entwerfen, implementieren und anwenden

**Ziel:** **Unittests** automatisieren, häufig ausführen (agil), und so **Regressionsfehler** früh erkennen. 

### Merkmale guter Unittests (F.I.R.S.T.)

1. **Fast** – schnell ausführbar.
2. **Independent** – unabhängig voneinander.
3. **Repeatable** – reproduzierbar mit identischem Ergebnis.
4. **Self-Validating** – liefern klar **grün/rot** ohne manuelle Prüfung.
5. **Timely** – idealerweise vor dem Produktivcode geschrieben.
   Weitere Kriterien: **Begrenztheit** (eine Eigenschaft pro Test), **Verständlichkeit**, **Wartbarkeit**, **Relevanz**. 

### Unittests in Java (JUnit 5, Jupiter API)

* Zentrale **Annotations**: `@Test`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll`, `@DisplayName`, `@Timeout`.
* Wichtige **Assertions**: `assertTrue`, `assertFalse`, `assertEquals`, `fail`.
* Ergebnisdarstellung: **grün** (erfolgreich) / **rot** (Fehler oder Failure via **Exception**/**AssertionFailedError**).
* Beispiel illustriert Test einer Summenfunktion und Trennung von Test- und Produktionscode.

### Unittests in Python (`unittest`)

* Ergebnisse: **OK**, **Failure** (AssertionError), **Error** (andere Fehler).
* Typische **Assertions**: `assertEqual`, `assertNotEqual`, `assertTrue`, `assertFalse`, `assertGreater`, `assertLess`, u. a.
* Beispiel testet eine Volumenfunktion inkl. Grenzwerten; Tests werden i. d. R. getrennt vom Produktionscode geführt. 

---

### Kernaussagen kompakt

* **Modultests/Unittests** sichern die **Funktionalität** einzelner Komponenten und sind Basis für **kontinuierliche Qualität**. 
* **Verfahrenswahl**: **Black-Box** (Spezifikation) ergänzt **White-Box** (Code); Kombination ist üblich. 
* **Testfälle** gezielt ableiten (**Äquivalenzklassen**, **Grenzwerte**, **Abdeckungsziele**). 
* **Automatisierung** steigert Skalierbarkeit und unterstützt **Regressionstests**, ersetzt manuelle Tests aber nicht vollständig. 
* Gute Unittests folgen **F.I.R.S.T.** und sind mit **JUnit**/**unittest** praxisnah umsetzbar.

---

## [Nächstes Thema](./2.4.1_Testverfahren_auswaehlen.md)