<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<style>
h1, h2, h3 {
  font-weight: 600;
  margin-top: 24px;
  margin-bottom: 12px;
}
ul {
  margin: 10px 0;
  padding-left: 20px;
}
blockquote {
  border-left: 4px solid #555;
  padding-left: 12px;
  color: #444;
  margin: 16px 0;
}
</style>
</head>
<body>

<h1>2.1.2 Softwarekomponenten mithilfe von UML beschreiben</h1>

<h2>Wiederholung bekannter UML-Diagramme</h2>
<ul>
  <li><b>Anwendungsfalldiagramm:</b> beschreibt Funktionalitäten aus Sicht der Nutzer.</li>
  <li><b>Klassendiagramm:</b> zeigt die Struktur des Systems (Klassen, Attribute, Methoden, Beziehungen).</li>
  <li><b>Aktivitätsdiagramm:</b> modelliert Abläufe und Kontrollflüsse innerhalb von Prozessen.</li>
</ul>

<h2>Neue UML-Diagramme</h2>
<ul>
  <li><b>Zustandsdiagramm:</b> beschreibt Zustände eines Objekts und die Übergänge zwischen ihnen.</li>
  <li><b>Sequenzdiagramm:</b> stellt die zeitliche Abfolge von Nachrichten zwischen Objekten dar.</li>
</ul>

<h2>Fallbeispiel: Softwareprojekt „Yachthafen Resort“</h2>
<p><b>Modul:</b> Yachthafenmanagement – <b>Komponente:</b> Liegeplatzverwaltung</p>

<h3>Funktionale Anforderungen</h3>
<ul>
  <li>Kunden können Liegeplätze <b>mieten</b> und <b>kündigen</b>.</li>
  <li>Kunden können ihre Yacht im Hafen <b>an-</b> und <b>abmelden</b>.</li>
  <li>Mitarbeiter können Liegeplätze für <b>Wartungsarbeiten sperren</b>.</li>
  <li>Alle Nutzer können die <b>aktuelle Belegung</b> einsehen.</li>
</ul>

<h2>Ziel der UML-Modellierung</h2>
<ul>
  <li>Objektorientierter Entwurf der Softwarekomponente.</li>
  <li>Sicherstellung von hoher Softwarequalität durch strukturierte Planung.</li>
  <li>Visualisierung verschiedener Aspekte der Software mit unterschiedlichen Diagrammtypen.</li>
</ul>

<blockquote>
<b>Merke:</b> UML unterstützt eine ganzheitliche Sicht auf Softwarekomponenten: 
Struktur (Klassen), Verhalten (Aktivitäten, Zustände) und Interaktion (Anwendungsfälle, Sequenzen).
</blockquote>

<h1>Anwendungsfalldiagramm (Use Case Diagram)</h1>

<h2>Notationselemente</h2>

<table>
  <tr>
    <th>Notationselement</th>
    <th>Bezeichnung</th>
    <th>Beschreibung</th>
  </tr>
  <tr>
    <td>Rechteck (System)</td>
    <td>Systemgrenze</td>
    <td>Umfasst alle Anwendungsfälle des Systems, innerhalb werden die Funktionen bereitgestellt.</td>
  </tr>
  <tr>
    <td>Strichmännchen</td>
    <td>Anwender / Akteur</td>
    <td>Externer Benutzer oder System, das mit dem System interagiert.</td>
  </tr>
  <tr>
    <td>Ellipse</td>
    <td>Anwendungsfall</td>
    <td>Aktion oder Funktion, die das System für einen Benutzer bereitstellt.</td>
  </tr>
  <tr>
    <td>Linie</td>
    <td>Assoziation</td>
    <td>Stellt die Beziehung zwischen Akteur und Anwendungsfall dar.</td>
  </tr>
</table>

<h2>Beziehungsarten</h2>

<ul>
  <li><b>Include-Beziehung:</b> bindet einen Anwendungsfall zwingend in einen anderen ein. (z. B. "Liegeplatz mieten" → "Verfügbarkeit prüfen")</li>
  <li><b>Extend-Beziehung:</b> bindet einen Anwendungsfall bedingt ein. (z. B. "Liegeplatz zuweisen" → erweitert "Liegeplatz sperren")</li>
  <li><b>Generalisierung/Spezialisierung:</b> Beziehung zwischen allgemeinem und spezialisiertem Element, möglich für Anwendungsfälle und Akteure.</li>
</ul>

<h2>Beispiel: Yachthafen Resort – Liegeplatzverwaltung</h2>

<p><b>Akteure:</b> Mieter, Mitarbeiter</p>

<h3>Anwendungsfälle für Mieter</h3>
<ul>
  <li>Liegeplatz mieten (inkl. Verfügbarkeit prüfen)</li>
  <li>Liegeplatz kündigen</li>
  <li>Yacht im Hafen anmelden</li>
  <li>Yacht im Hafen abmelden</li>
  <li>Belegung ansehen</li>
</ul>

<h3>Anwendungsfälle für Mitarbeiter</h3>
<ul>
  <li>Liegeplatz sperren (inkl. Verfügbarkeit prüfen)</li>
  <li>Liegeplatz freigeben</li>
  <li>Liegeplatz zuweisen (erweitert "Liegeplatz sperren", wenn ein gemieteter Platz gesperrt werden muss)</li>
  <li>Belegung ansehen</li>
</ul>

<h2>Interpretation des Beispiels</h2>
<ul>
  <li>Kunden können Liegeplätze mieten, kündigen und ihre Yacht an-/abmelden.</li>
  <li>Mitarbeiter können Plätze sperren, freigeben und im Bedarfsfall Ersatzplätze zuweisen.</li>
  <li>Vor jeder Miete oder Zuweisung wird die Verfügbarkeit automatisch geprüft.</li>
  <li>Alle Benutzer haben Zugriff auf die aktuelle Belegung.</li>
</ul>

<blockquote>
<b>Merke:</b> Anwendungsfalldiagramme zeigen das Systemverhalten aus Benutzersicht. Sie dienen als Grundlage für Anforderungen und Kommunikation mit Stakeholdern.
</blockquote>

### Beispieldiagramme

![Anwendungsfalldiagramm - Übersicht](/uml/Anwendungsfalldiagramm/Anwendungsfalldiagramm.png)
_Figur: Anwendungsfalldiagramm — Übersicht der Akteure und Anwendungsfälle._

![Anwendungsfalldiagramm - Detail A](/uml/Anwendungsfalldiagramm/Anwendungsfalldiagramms.png)
_Figur: Detailansicht mit Include/Extend-Beziehungen._

![Anwendungsfalldiagramm - Notation](/uml/Anwendungsfalldiagramm/Anwendungsfalldiagramms_1.png)
_Figur: Notationselemente und Legende._

<h1>Klassendiagramm (UML)</h1>

<h2>Notationselemente</h2>

<table>
  <tr>
    <th>Notationselement</th>
    <th>Bezeichnung</th>
    <th>Beschreibung</th>
  </tr>
  <tr>
    <td>Rechteck</td>
    <td>Klasse</td>
    <td>Darstellung von Klassenname, Attributen und Methoden. Klassenname im Singular, großgeschrieben.</td>
  </tr>
  <tr>
    <td>Rechteck (vereinfacht)</td>
    <td>Alternative Klassendarstellung</td>
    <td>Nur Klassenname, dient zur Modellierung von Beziehungen.</td>
  </tr>
  <tr>
    <td>+ / - / #</td>
    <td>Sichtbarkeit</td>
    <td>+ public, - private, # protected → Zugriffsmodifikatoren der OOP.</td>
  </tr>
  <tr>
    <td>Linie</td>
    <td>Assoziation</td>
    <td>Beziehung zwischen zwei Klassen. Gerichtete Assoziationen mit Pfeil.</td>
  </tr>
  <tr>
    <td>Leere Raute</td>
    <td>Aggregation</td>
    <td>„schwache“ Teil-Ganzes-Beziehung (z. B. Klasse nutzt andere).</td>
  </tr>
  <tr>
    <td>Gefüllte Raute</td>
    <td>Komposition</td>
    <td>„starke“ Teil-Ganzes-Beziehung. Teil existiert nur mit dem Ganzen.</td>
  </tr>
  <tr>
    <td>1, 0..*</td>
    <td>Multiplizität</td>
    <td>Gibt an, wie viele Objekte in Beziehung stehen (z. B. 1 Yacht ↔ 1 Liegeplatz).</td>
  </tr>
  <tr>
    <td>Dreieck</td>
    <td>Vererbung</td>
    <td>Unterklasse erbt von Oberklasse. Bei Interfaces gestrichelte Linie.</td>
  </tr>
</table>

<h2>Beispiel: Yachthafen Resort – Klassendiagramm</h2>

<h3>Klassen</h3>
<ul>
  <li><b>Yacht</b>: Attribute wie Name, Länge, Tiefgang. Methoden z. B. Konstruktor.</li>
  <li><b>Liegeplatz</b>: Attribute wie Nummer, Status, Yacht, Mieter. Methoden u. a. <code>mieten()</code>, <code>kündigen()</code>, <code>anmelden()</code>, <code>abmelden()</code>, <code>sperren()</code>, <code>freigeben()</code>, <code>istVerfügbar()</code>.</li>
  <li><b>Mieter</b>: Attribute wie Name, Vorname, Anschrift, Telefon. Methoden z. B. Konstruktor.</li>
</ul>

<h3>Beziehungen</h3>
<ul>
  <li><b>Aggregation:</b> Liegeplatz ist mit <b>Mieter</b> und <b>Yacht</b> verbunden. Jeder Mieter und jede Yacht belegt einen Liegeplatz.</li>
  <li>Multiplizität: 1:1-Beziehung zwischen Yacht und Liegeplatz sowie zwischen Mieter und Liegeplatz.</li>
  <li>Beziehung ist so gewählt, dass Objekte auch unabhängig bestehen können (schwache Bindung).</li>
</ul>

<h2>Besonderheiten</h2>
<ul>
  <li>Auf Getter- und Setter-Methoden wurde verzichtet, nur Arbeitsmethoden sind modelliert.</li>
  <li>Erweiterung durch neue Klassen oder Vererbungen jederzeit möglich.</li>
  <li>Bei Spezialisierungen müssten Sichtbarkeiten angepasst werden (<code>private</code>, <code>protected</code>).</li>
</ul>

<blockquote>
<b>Merke:</b> Klassendiagramme beschreiben Struktur, Attribute, Methoden und Beziehungen von Klassen – zentrale Grundlage für objektorientiertes Design.
</blockquote>

![Klassendiagramm - Übersicht](/uml/Klassendiagramm/Klassendiagramms.png)
_Figur: Klassendiagramm — Übersicht der Klassen und Beziehungen._


![Klassendiagramm - Notation](/uml/Klassendiagramm/Klassendiagramms_1.png)
_Figur: Notationselemente und Legende._

![Klassendiagramm - Detail](/uml/Klassendiagramm/Klassendiagramms_.png)
_Figur: Detailansicht mit Attributen, Methoden und Beziehungen._

<h1>Aktivitätsdiagramm (UML)</h1>

<h2>Notationselemente</h2>

<table>
  <tr>
    <th>Notation</th>
    <th>Bezeichnung</th>
    <th>Beschreibung</th>
  </tr>
  <tr>
    <td>●</td>
    <td>Startknoten</td>
    <td>Markiert den Beginn eines Ablaufs.</td>
  </tr>
  <tr>
    <td>◎ / ⊗</td>
    <td>Endknoten / Ablaufende</td>
    <td>Markiert das Ende des Ablaufs bzw. eines Zweigs.</td>
  </tr>
  <tr>
    <td>Rechteck</td>
    <td>Aktion</td>
    <td>Beschreibt ein Verhalten oder eine Tätigkeit.</td>
  </tr>
  <tr>
    <td>Pfeil</td>
    <td>Kante</td>
    <td>Stellt Kontrollfluss zwischen Aktionen dar.</td>
  </tr>
  <tr>
    <td>Rhombus</td>
    <td>Verzweigung</td>
    <td>Je nach Bedingung wird eine von mehreren Aktionen ausgeführt.</td>
  </tr>
  <tr>
    <td>Rhombus (zusammen)</td>
    <td>Zusammenführung</td>
    <td>Nach A oder B wird C ausgeführt.</td>
  </tr>
  <tr>
    <td>|| (aufgeteilt)</td>
    <td>Aufspaltung</td>
    <td>Nach A werden mehrere Aktionen parallel gestartet.</td>
  </tr>
  <tr>
    <td>|| (zusammengeführt)</td>
    <td>Synchronisation</td>
    <td>Erst wenn alle parallelen Aktionen abgeschlossen sind, geht es weiter.</td>
  </tr>
  <tr>
    <td>Großes Rechteck</td>
    <td>Aktivität</td>
    <td>Rahmen für Aktionen und Kontrollflüsse; kann Ein- und Ausgabeparameter enthalten.</td>
  </tr>
</table>

<h2>Beispiel: Prozess „Liegeplatz mieten“</h2>

<h3>Akteure/Partitionen</h3>
<ul>
  <li><b>Kunde:</b> wählt Liegeplatz, sendet Anfrage, gibt Daten ein, bestätigt Vermietung.</li>
  <li><b>Programm:</b> zeigt Liegeplätze, prüft Verfügbarkeit, zeigt Eingabefenster, speichert Daten, versendet Bestätigungsmail.</li>
</ul>

<h3>Ablauf</h3>
<ol>
  <li>Kunde startet Prozess (Startknoten).</li>
  <li>Programm zeigt Liste verfügbarer Liegeplätze.</li>
  <li>Kunde wählt Liegeplatz und sendet Anfrage.</li>
  <li>Programm prüft Verfügbarkeit:
    <ul>
      <li>[nicht verfügbar] → Meldung anzeigen.</li>
      <li>[verfügbar] → Eingabeformular anzeigen.</li>
    </ul>
  </li>
  <li>Kunde gibt Daten ein und sendet diese ab.</li>
  <li>Programm speichert Daten und bestätigt Vermietung.</li>
  <li>Programm sendet E-Mail mit Metadaten an Kunden.</li>
  <li>Prozess endet (Endknoten).</li>
</ol>

<h2>Besonderheiten</h2>
<ul>
  <li>Diagramm ist in <b>zwei Partitionen</b> aufgeteilt (Kunde/Programm).</li>
  <li>Prozess kann jederzeit abgebrochen werden.</li>
  <li>Modelliert Kontrollfluss und parallele Abläufe klar und verständlich.</li>
</ul>

<blockquote>
<b>Merke:</b> Aktivitätsdiagramme eignen sich besonders zur Darstellung von Geschäftsprozessen und Arbeitsabläufen – mit Verzweigungen, Parallelität und Synchronisation.
</blockquote>

![Aktivitätsdiagramm - Übersicht](/uml/Aktivitätsdiagramm/Aktivitätsdiagramms.png)
_Figur: Aktivitätsdiagramm — Ablauf des Prozesses "Liegeplatz mieten" mit Partitionen Kunde/Programm._

![Aktivitätsdiagramm - Notation](/uml/Aktivitätsdiagramm/Aktivitätsdiagramms_.png)
_Figur: Notationselemente des Aktivitätsdiagramms (Start-/Endknoten, Aktionen, Verzweigungen, Aufspaltung/Synchronisation)._


<h1>Zustandsdiagramm (UML)</h1>

<h2>Zweck</h2>
<ul>
  <li>Dient zur Darstellung der möglichen <b>Zustände</b> eines Objekts und deren Übergänge.</li>
  <li>Beschreibt das <b>dynamische Verhalten</b> eines Systems.</li>
  <li>Im Gegensatz zu Aktivitätsdiagrammen liegt der Fokus auf <b>Reaktionen</b> des Systems (z. B. auf Eingaben).</li>
  <li>Wird v. a. in der <b>Analyse- und Entwurfsphase</b> als Ergänzung zu Klassendiagrammen eingesetzt.</li>
</ul>

<h2>Notationselemente</h2>

<table>
  <tr>
    <th>Notation</th>
    <th>Bezeichnung</th>
    <th>Beschreibung</th>
  </tr>
  <tr>
    <td>●</td>
    <td>Anfangszustand</td>
    <td>Startpunkt, nur einmal vorhanden.</td>
  </tr>
  <tr>
    <td>◎</td>
    <td>Endzustand</td>
    <td>Terminiert die Zustandsänderung, danach keine Übergänge mehr.</td>
  </tr>
  <tr>
    <td>Rechteck mit Name</td>
    <td>Zustand</td>
    <td>Benennt einen möglichen Zustand eines Objekts.</td>
  </tr>
  <tr>
    <td>Pfeil</td>
    <td>Transition</td>
    <td>Zustandswechsel ausgelöst durch <b>Ereignis</b>, <b>Bedingung</b> und <b>Handlung</b>.</td>
  </tr>
  <tr>
    <td>Rhombus</td>
    <td>Verzweigung</td>
    <td>Je nach Bedingung führt Transition in unterschiedliche Zustände.</td>
  </tr>
</table>

<h2>Beispiel 1: Liegeplatzverwaltung (Yachthafen)</h2>
<ul>
  <li>Zustände: <b>verfügbar</b>, <b>vermietet</b>, <b>gesperrt</b>, <b>belegt</b>.</li>
  <li>Transitions: <code>mieten</code>, <code>kündigen</code>, <code>freigeben</code>, <code>sperren</code>, <code>anmelden</code>, <code>abmelden</code>.</li>
  <li>Start: Liegeplatz anlegen → Zustand „verfügbar“.</li>
  <li>Ende: Liegeplatz entfernen.</li>
  <li>Zustände spiegeln Methoden der Klasse <code>Liegeplatz</code> wider.</li>
</ul>

<h2>Beispiel 2: Bibliotheksverwaltung (Buch)</h2>
<ul>
  <li><b>Zustände:</b> bereit, ausgeliehen, vorgemerkt, abholbereit, ausgesondert.</li>
  <li><b>Transitions:</b> erwerben, ausleihen, zurückgeben, vormerken, aussortieren (Buch unbrauchbar oder verloren).</li>
  <li>Zustandsübergänge modellieren alle möglichen Status eines Buches innerhalb der Bibliothek.</li>
</ul>

<h2>Besonderheiten</h2>
<ul>
  <li>Zustandsdiagramme sind eng mit Methoden der zugehörigen Klassen verknüpft.</li>
  <li>Übergänge basieren auf Ereignissen (Triggern) und ggf. Bedingungen (Guards).</li>
  <li>Verhalten von Benutzeroberflächen lässt sich damit sehr gut modellieren (reaktiv, zustandsabhängig).</li>
</ul>

<blockquote>
<b>Merke:</b> Zustandsdiagramme machen deutlich, in welchem Status sich ein Objekt befindet und welche Ereignisse Zustandsänderungen bewirken.
</blockquote>

<h1>Zustandsdiagramm (UML)</h1>

<h2>Zweck</h2>
<ul>
  <li>Dient zur Darstellung der möglichen <b>Zustände</b> eines Objekts und deren Übergänge.</li>
  <li>Beschreibt das <b>dynamische Verhalten</b> eines Systems.</li>
  <li>Im Gegensatz zu Aktivitätsdiagrammen liegt der Fokus auf <b>Reaktionen</b> des Systems (z. B. auf Eingaben).</li>
  <li>Wird v. a. in der <b>Analyse- und Entwurfsphase</b> als Ergänzung zu Klassendiagrammen eingesetzt.</li>
</ul>

<h2>Notationselemente</h2>

<table>
  <tr>
    <th>Notation</th>
    <th>Bezeichnung</th>
    <th>Beschreibung</th>
  </tr>
  <tr>
    <td>●</td>
    <td>Anfangszustand</td>
    <td>Startpunkt, nur einmal vorhanden.</td>
  </tr>
  <tr>
    <td>◎</td>
    <td>Endzustand</td>
    <td>Terminiert die Zustandsänderung, danach keine Übergänge mehr.</td>
  </tr>
  <tr>
    <td>Rechteck mit Name</td>
    <td>Zustand</td>
    <td>Benennt einen möglichen Zustand eines Objekts.</td>
  </tr>
  <tr>
    <td>Pfeil</td>
    <td>Transition</td>
    <td>Zustandswechsel ausgelöst durch <b>Ereignis</b>, <b>Bedingung</b> und <b>Handlung</b>.</td>
  </tr>
  <tr>
    <td>Rhombus</td>
    <td>Verzweigung</td>
    <td>Je nach Bedingung führt Transition in unterschiedliche Zustände.</td>
  </tr>
</table>

<h2>Beispiel 1: Liegeplatzverwaltung (Yachthafen)</h2>
<ul>
  <li>Zustände: <b>verfügbar</b>, <b>vermietet</b>, <b>gesperrt</b>, <b>belegt</b>.</li>
  <li>Transitions: <code>mieten</code>, <code>kündigen</code>, <code>freigeben</code>, <code>sperren</code>, <code>anmelden</code>, <code>abmelden</code>.</li>
  <li>Start: Liegeplatz anlegen → Zustand „verfügbar“.</li>
  <li>Ende: Liegeplatz entfernen.</li>
  <li>Zustände spiegeln Methoden der Klasse <code>Liegeplatz</code> wider.</li>
</ul>

<h2>Beispiel 2: Bibliotheksverwaltung (Buch)</h2>
<ul>
  <li><b>Zustände:</b> bereit, ausgeliehen, vorgemerkt, abholbereit, ausgesondert.</li>
  <li><b>Transitions:</b> erwerben, ausleihen, zurückgeben, vormerken, aussortieren (Buch unbrauchbar oder verloren).</li>
  <li>Zustandsübergänge modellieren alle möglichen Status eines Buches innerhalb der Bibliothek.</li>
</ul>

<h2>Besonderheiten</h2>
<ul>
  <li>Zustandsdiagramme sind eng mit Methoden der zugehörigen Klassen verknüpft.</li>
  <li>Übergänge basieren auf Ereignissen (Triggern) und ggf. Bedingungen (Guards).</li>
  <li>Verhalten von Benutzeroberflächen lässt sich damit sehr gut modellieren (reaktiv, zustandsabhängig).</li>
</ul>

<blockquote>
<b>Merke:</b> Zustandsdiagramme machen deutlich, in welchem Status sich ein Objekt befindet und welche Ereignisse Zustandsänderungen bewirken.
</blockquote>


![Zustandsdiagramm - Übersicht](/uml/Zustandsdiagramm/Zustandsdiagramms.png)  
_Figur: Zustandsdiagramm — Übersicht der Zustände und Übergänge._

![Zustandsdiagramm - Notation](/uml/Zustandsdiagramm/Zustandsdiagramms_1.png)  
_Figur: Notationselemente und Legende._

![Zustandsdiagramm - Detail](/uml/Zustandsdiagramm/Zustandsdiagramms_.png)  
_Figur: Detailansicht mit Zuständen, Transitionen und Bedingungen._

--- 

<h1>Sequenzdiagramm – Übersicht und Anwendung</h1>

<h2>Definition und Zweck</h2>
<p>Sequenzdiagramme visualisieren den zeitlichen Ablauf von Interaktionen zwischen Objekten in einem System. Sie zeigen, <b>wann</b> ein Objekt aktiviert wird, <b>welche Nachrichten</b> es sendet oder empfängt und <b>wann</b> Objekte erzeugt oder gelöscht werden. Sie werden in der <b>Analysephase</b> zur Darstellung von Nachrichtenflüssen und in der <b>Entwurfsphase</b> zur Beschreibung der Benutzerinteraktionen verwendet.</p>

<h2>Wichtige Notationselemente</h2>

<table>
<tr><th>Element</th><th>Bezeichnung</th><th>Beschreibung</th></tr>
<tr><td><b>Interaktionsrahmen</b></td><td>Interaktionsrahmen</td><td>Umschließt das zu beschreibende Verhalten. Oben steht der Name des Diagramms.</td></tr>
<tr><td><b>Lebenslinie</b></td><td>Objekt-Lebenslinie</td><td>Darstellung des Objekts (Rechteck mit Klassenname). Die gestrichelte Linie symbolisiert die Zeitdauer der Existenz.</td></tr>
<tr><td><b>Aktivierung</b></td><td>Aktivierung</td><td>Schmales Rechteck, zeigt die Zeit, in der das Objekt aktiv ist (z. B. Methodenaufruf).</td></tr>
<tr><td><b>Löschung</b></td><td>Löschung</td><td>Beendet die Existenz eines Objekts, gekennzeichnet durch ein „X“ auf der Lebenslinie.</td></tr>
<tr><td><b>Synchrone Nachricht</b></td><td>Pfeil mit gefüllter Spitze</td><td>Sender wartet auf Antwort, bevor es fortfährt.</td></tr>
<tr><td><b>Asynchrone Nachricht</b></td><td>Pfeil mit offener Spitze</td><td>Sender setzt Prozess fort, ohne auf Antwort zu warten.</td></tr>
<tr><td><b>Antwort</b></td><td>Rückmeldung</td><td>Gestrichelte Linie mit offener Pfeilspitze zeigt Rückgabe eines Ergebnisses an.</td></tr>
<tr><td><b>Selbstdelegation</b></td><td>Selbstaufruf</td><td>Ein Objekt ruft eine eigene Methode auf.</td></tr>
</table>

<h2>Interaktionsfragmente</h2>
<p>Fragmente beeinflussen den Ablauf, z. B. durch Bedingungen oder Schleifen.</p>

<ul>
<li><code>alt</code> – Alternative (if/else)</li>
<li><code>loop</code> – Schleife (Wiederholung)</li>
<li><code>opt</code> – Option (optional)</li>
<li><code>par</code> – Parallel (gleichzeitige Abläufe)</li>
</ul>

<h2>Allgemeines Beispiel</h2>
<p><b>:K1</b> sendet Nachrichten an <b>:K2</b>. Anschließend wird ein Objekt <b>:K3</b> erzeugt (<code>create()</code>) und später gelöscht (<code>destroy()</code>).</p>

<h2>Beispiel: Yacht im Hafen anmelden</h2>
<ul>
<li><b>Mieter</b> übermittelt Anmeldedaten an <b>MeldeApp</b>.</li>
<li><b>MeldeApp</b> überprüft über die <b>Datenbank</b> die Daten.</li>
<li>Je nach Ergebnis (alt-Fragment):</li>
  <ul>
    <li>[Daten OK] → Yacht wird angelegt, Anmeldung bestätigt.</li>
    <li>[sonst] → Anmeldung wird abgelehnt.</li>
  </ul>
</ul>

<h2>Beispiel: Anmeldung im Onlineportal</h2>
<ul>
<li><b>loop</b>: Solange Anmeldedaten falsch oder Versuche &lt; 3, wird die Anmeldung wiederholt.</li>
<li><b>:Benutzer</b> → sendet <code>login(name, pw)</code> an <b>:Onlineportal</b>.</li>
<li><b>:Onlineportal</b> → ruft <code>check(name, pw)</code> in <b>:Datenbank</b> auf.</li>
<li>Ergebnis wird zurückgegeben.</li>
<li><b>alt</b>:
  <ul>
    <li>[falsch] → Fehlermeldung</li>
    <li>[sonst] → Anmeldung OK</li>
  </ul>
</li>
</ul>

<h2>Prüfungsrelevante Merksätze</h2>
<ul>
<li>Sequenzdiagramme modellieren <b>Nachrichtenfluss zwischen Objekten</b>.</li>
<li>Die Zeitachse verläuft <b>von oben nach unten</b>.</li>
<li>Synchrone Nachrichten: warten auf Antwort; Asynchrone: keine Wartezeit.</li>
<li>Lebenslinien zeigen <b>Existenzdauer</b> eines Objekts.</li>
<li>Interaktionsfragmente steuern <b>Bedingungen und Schleifen</b>.</li>
<li>Ideal für Analyse- und Entwurfsphase.</li>
</ul>

![Sequenzdiagramm - Übersicht](/uml/Sequenzdiagramm/image_1.png)  
_Figur: Sequenzdiagramm — Übersicht der Akteure, Lebenslinien und Nachrichten._

![Sequenzdiagramm - Notation](/uml/Sequenzdiagramm/image_2.png)  
_Figur: Notationselemente (Lebenslinie, Aktivierung, synchrone/asynchrone Nachrichten, Antworten)._

![Sequenzdiagramm - Detail](/uml/Sequenzdiagramm/image_3.png)  
_Figur: Detailansicht mit Interaktionsfragmenten (alt/loop/opt), Aktivierungsbalken und Nachrichtenflüssen._



</body>
</html>

