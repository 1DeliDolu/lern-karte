# 2.1.3 Entwurfsmuster unterscheiden und verwenden

<section style="font-family: 'Segoe UI', Roboto, sans-serif; color: #000; background: #fff; padding: 24px; line-height: 1.6; margin: auto; border-radius: 12px; box-shadow: 0 0 10px rgba(0,0,0,0.1);">

## 🧩 2.1.3 Entwurfsmuster – Grundlagen und Anwendung

### 💡 Definition

Ein **Entwurfsmuster (Design Pattern)** ist eine **bewährte, flexible Lösung** für ein **wiederkehrendes Problem** in der Softwareentwicklung.
Sie dienen der Strukturierung, Wiederverwendbarkeit und Wartbarkeit von Code.

---

### 🏗️ Kategorien von Entwurfsmustern

| Kategorie                         | Beschreibung                                              | Beispiele                   |
| --------------------------------- | --------------------------------------------------------- | --------------------------- |
| **Erzeugungsmuster (Creational)** | Regeln die **Erstellung von Objekten**                    | Factory, Singleton, Builder |
| **Strukturmuster (Structural)**   | Beschreiben **Beziehungen und Zusammenspiel** von Klassen | Adapter, Bridge, Facade     |
| **Verhaltensmuster (Behavioral)** | Bestimmen **Interaktionen und Verantwortlichkeiten**      | Observer, Command, Iterator |

---

### ⚙️ Factory Pattern (Erzeugungsmuster)

**Zweck:**
Trennung von Objekterstellung und Nutzung. Der Client kennt nicht die konkreten Klassen, sondern arbeitet über ein **Interface**.

**Aufbau:**

* Eine **Factory-Klasse** erzeugt Objekte bestimmter Typen.
* Der **Client** fordert über die Factory ein Objekt an.
* Neue Typen können leicht ergänzt werden, ohne den Client-Code zu ändern.

**Vorteil:** Hohe Flexibilität und Erweiterbarkeit bei der Objekterzeugung.

```text
Client → Factory → Interface → konkrete Klassen (Type 1, Type 2)
```
![Factory](/Entwurfsmuster/Adapter.png)
---

### 🔁 Singleton Pattern (Erzeugungsmuster)

**Problem:**
Es soll **nur eine einzige Instanz** einer Klasse existieren (z. B. Log-Datei, Druckerzugriff).

**Lösung:**

* Der **Konstruktor ist privat**, um Mehrfacherzeugung zu verhindern.
* Eine **statische Methode `getInstance()`** liefert das einzige Objekt zurück.
* Die Klasse verwaltet ihre eigene Instanz intern.

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}
```

---

### ⚖️ Vor- und Nachteile des Singleton-Patterns

| ✅ Vorteile                            | ⚠️ Nachteile                      |
| ------------------------------------- | --------------------------------- |
| Einfach umsetzbar                     | Gefahr „quasi-globaler“ Variablen |
| Spart Ressourcen (Lazy Instantiation) | Erschwerte Testbarkeit            |
| Vermeidung globaler Variablen         | Problematisch bei Multithreading  |
| Kann durch Vererbung angepasst werden | Schwierige Ressourcenfreigabe     |


[Singleton](/Entwurfsmuster/Singleton.png)
---

### 🚫 Anti-Pattern

**Definition:** Schlechte oder schädliche Entwurfspraktiken.
Beispiele:

* **Gottobjekt:** Klasse mit zu vielen Verantwortlichkeiten → Verletzung der Modularisierung
* **Zwiebel:** Neue Funktionen werden unstrukturiert „um alten Code“ gebaut
* **Copy & Paste:** Übernahme von Code ohne Verständnis oder Anpassung

Selbst **Design Patterns** wie Singleton können bei Übernutzung zu **Anti-Pattern** werden (eingeschränkte Skalierbarkeit, Testprobleme).

---

### 📘 Fazit

Entwurfsmuster sind **Werkzeuge für wiederkehrende Entwurfsprobleme**, keine starren Regeln.
Sie fördern **sauberen, wartbaren und flexiblen Code**, sollten jedoch **gezielt und bedarfsgerecht** eingesetzt werden.

</section>

<section style="font-family:'Segoe UI', Roboto, sans-serif; color:#000; background:#fff; padding:24px; line-height:1.6; max-width:900px; margin:auto; border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1);">

## 🏭 Factory Pattern (Erzeugungsmuster)

### 💡 Ziel

Das **Factory Pattern** trennt die **Erzeugung von Objekten** von deren **Verwendung**.
Der Client arbeitet nur mit **abstrakten Klassen oder Interfaces** und kennt die konkreten Implementierungen nicht.

---

### ⚙️ Problemstellung

* Zur **Entwicklungszeit** ist nicht bekannt, welche konkreten Klassen später instanziiert werden müssen.
* Der **Erstellungsprozess von Objekten** soll **einfach erweiterbar** und **unabhängig von der Nutzung** sein.
* Typische Einsatzgebiete: Frameworks, Bibliotheken, Plugin-Systeme.

---

### 🧠 Lösungskonzept

Das Factory Pattern nutzt **abstrakte Erzeuger- und Produktklassen**:

1. **Abstrakter Erzeuger (Creator/Factory)**

   * Definiert die Methode `erzeugeProdukt()`, die ein abstraktes Produkt zurückgibt.
   * Wird in Unterklassen **überschrieben**.

2. **Konkreter Erzeuger**

   * Implementiert die Methode und erzeugt ein **konkretes Produktobjekt**.
   * Enthält einen **Verweis auf das konkrete Produkt**.

3. **Abstraktes Produkt**

   * Definiert das gemeinsame Interface für alle Produktvarianten.

4. **Konkretes Produkt**

   * Implementiert das Interface des abstrakten Produkts.

![Factory](/Entwurfsmuster/Factory.png)

---

### 🔁 Aufbauübersicht

```text
Client
  ↓
Erzeuger (abstract)
  ↳ + erzeugeProdukt(): Produkt
      ↓
KonkreterErzeuger → KonkretesProdukt
Produkt (abstract)
```

➡️ **Im Client werden nur abstrakte Klassen verwendet.**
➡️ **Der konkrete Erzeuger entscheidet, welches Produkt erzeugt wird.**

---

### 🧩 Beispiel (Java)

```java
abstract class Produkt {
    abstract void anzeigen();
}

class KonkretesProdukt extends Produkt {
    void anzeigen() { System.out.println("Konkretes Produkt erstellt."); }
}

abstract class Erzeuger {
    abstract Produkt erzeugeProdukt();
}

class KonkreterErzeuger extends Erzeuger {
    Produkt erzeugeProdukt() { return new KonkretesProdukt(); }
}
```

---

### ⚖️ Vor- und Nachteile

| ✅ Vorteile                                               | ⚠️ Nachteile                                                   |
| -------------------------------------------------------- | -------------------------------------------------------------- |
| Gute Erweiterbarkeit für neue Produkttypen               | Enge Koppelung zwischen Erzeuger und Produkt                   |
| Erzeugung ist von der Verwendung getrennt                | Für jedes neue Produkt muss ein neuer Erzeuger erstellt werden |
| Nutzung unbekannter Objekte zur Entwicklungszeit möglich | Hohe Klassenanzahl bei vielen Produkten                        |

---

### 📘 Fazit

Das **Factory Pattern** ist ein zentrales Erzeugungsmuster der objektorientierten Programmierung.
Es ermöglicht **flexible, erweiterbare Softwarearchitekturen**, besonders in Frameworks, bei denen konkrete Objekte erst **zur Laufzeit** bestimmt werden.

</section>

--- 
<section style="font-family:'Segoe UI', Roboto, sans-serif; color:#000; background:#fff; padding:24px; line-height:1.6; max-width:900px; margin:auto; border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1);">

## 🔌 Adapter Pattern (Strukturmuster)

### 💡 Ziel

Das **Adapter Pattern** verbindet **inkompatible Schnittstellen**, sodass bestehende Klassen weiterhin genutzt werden können, ohne deren Code zu verändern.
Es dient der **Anpassung und Wiederverwendung** von Softwarekomponenten.

---

### ⚙️ Problemstellung

* Eine **bestehende Klasse** bietet die gewünschte Funktionalität, jedoch **nicht die benötigte Schnittstelle**.
* Der Code dieser Klasse (z. B. aus einer Drittanbieter-Bibliothek) **kann oder soll nicht geändert werden**.
* Der **Klient** benötigt eine **andere Schnittstelle**, um mit der Klasse zu kommunizieren.

📘 **Beispiel:**
Ein **USB-zu-Ethernet-Adapter** verbindet zwei inkompatible Schnittstellen – dieses Prinzip überträgt das Pattern auf Software.

---

### 🧠 Lösungskonzept

Der **Adapter** übersetzt die Schnittstelle der adaptierten Klasse in die Schnittstelle, die der Klient erwartet.
Es gibt **zwei Varianten**:

#### 1️⃣ Umsetzung mittels **Delegation (Objektadapter)**

* Der Adapter **enthält eine Instanz** der adaptierten Klasse.
* Er **delegiert** Aufrufe der Client-Schnittstelle an die passende Methode der adaptierten Klasse.
* **Flexibel**, da auch Unterklassen adaptiert werden können.

```java
class Adapter implements Schnittstelle {
    private AdaptierteKlasse adaptiert;
    public void operation() {
        adaptiert.spezifischeOperation();
    }
}
```

#### 2️⃣ Umsetzung mittels **Vererbung (Klassenadapter)**

* Der Adapter **erbt** von der adaptierten Klasse **und** implementiert die benötigte Schnittstelle.
* **Effizient**, aber weniger flexibel (funktioniert nicht für Unterklassen).

```java
class Adapter extends AdaptierteKlasse implements Schnittstelle {
    public void operation() {
        spezifischeOperation();
    }
}
```

---

### 🔁 Strukturübersicht

| Objektadapter (Delegation)             | Klassenadapter (Vererbung)              |
| -------------------------------------- | --------------------------------------- |
| Adapter **enthält** adaptiertes Objekt | Adapter **erbt** von adaptiertem Objekt |
| Basiert auf **Komposition**            | Basiert auf **Vererbung**               |
| Kann **mehrere Klassen** anpassen      | Kann **nur eine Klasse** anpassen       |
| **Höhere Flexibilität**                | **Schnellere Implementierung**          |

---

### ⚖️ Vor- und Nachteile

| ✅ Vorteile                                    | ⚠️ Nachteile                                    |
| --------------------------------------------- | ----------------------------------------------- |
| Erhöht Wiederverwendbarkeit von Komponenten   | Zusätzliche Zwischenklasse                      |
| Objektadapter kann auch Unterklassen anpassen | Klassenadapter kann keine Unterklassen anpassen |
| Gute Trennung von Schnittstellen              | Kann zu komplexeren Strukturen führen           |

![Adapter](/Entwurfsmuster/Adapter.png)
---

### 📘 Fazit

Das **Adapter Pattern** ist ein wichtiges **Strukturmuster**, das hilft, alte oder fremde Klassen in neue Systeme zu integrieren.
Es bietet eine **Brücke zwischen inkompatiblen Schnittstellen** – analog zu realen Hardware-Adaptern.

</section>

---

<section style="font-family:'Segoe UI', Roboto, sans-serif; color:#000; background:#fff; padding:24px; line-height:1.6; max-width:900px; margin:auto; border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1);">

## 👁️ Observer Pattern (Beobachter-Muster)

### 💡 Ziel

Das **Observer Pattern** (Beobachter-Muster) dient der **Trennung von Datenhaltung und Darstellung**.
Es sorgt dafür, dass **alle abhängigen Komponenten automatisch über Änderungen informiert werden**, ohne dass sie eng gekoppelt sind.

---

### ⚙️ Problemstellung

* Änderungen an einem Objekt sollen **automatisch an abhängige Objekte weitergegeben** werden.
* Die **Informationsquelle (Subjekt)** und die **Empfänger (Beobachter)** sollen **unabhängig voneinander** bleiben.
* Beispiel:
  Im **MVC-Pattern** (Model-View-Controller) muss die **View** informiert werden, wenn sich die Daten im **Model** ändern.

---

### 🧠 Lösungskonzept

Das Observer Pattern gehört zu den **Verhaltensmustern (Behavioral Design Patterns)**.
Ein **Subjekt** verwaltet eine Liste von **Beobachtern** und informiert diese bei Änderungen seines Zustands.

#### 🔩 Hauptbestandteile

| Klasse                    | Aufgabe                                                                                                  |
| ------------------------- | -------------------------------------------------------------------------------------------------------- |
| **Subjekt**               | Verwaltung der Beobachter (Anmelden, Abmelden, Benachrichtigen)                                          |
| **Beobachter (Observer)** | Definiert eine Methode `aktualisieren()`, die aufgerufen wird, wenn sich der Zustand des Subjekts ändert |
| **Konkretes Subjekt**     | Enthält den aktuellen Zustand und ruft `benachrichtigen()` bei Änderungen auf                            |
| **Konkreter Beobachter**  | Reagiert auf Änderungen und aktualisiert seine Daten                                                     |

---

### 🔁 Varianten der Umsetzung

| Variante                     | Beschreibung                                                   |
| ---------------------------- | -------------------------------------------------------------- |
| **Push Notification**        | Subjekt benachrichtigt Beobachter, diese holen selbst Daten ab |
| **Push-Update Notification** | Subjekt sendet Änderungen direkt an Beobachter                 |
| **Pull Notification**        | Beobachter fragen selbstständig den Zustand beim Subjekt ab    |

---

### 🧩 UML-Ablauf (vereinfacht)

```text
Subjekt
 ├─ + anmelden(Beobachter)
 ├─ + abmelden(Beobachter)
 └─ + benachrichtigen()
        ↓
Beobachter
 └─ + aktualisieren()
```

➡️ Bei Zustandsänderung ruft das Subjekt alle registrierten Beobachter auf.
➡️ Beobachter holen sich neue Daten oder werden direkt informiert.

---

### 🧮 Beispiel (Java)

```java
interface Beobachter {
    void aktualisieren();
}

class Subjekt {
    private List<Beobachter> beobachterListe = new ArrayList<>();
    void anmelden(Beobachter b) { beobachterListe.add(b); }
    void abmelden(Beobachter b) { beobachterListe.remove(b); }
    void benachrichtigen() { for (Beobachter b : beobachterListe) b.aktualisieren(); }
}
```

---

### ⚖️ Vor- und Nachteile des Observer Patterns

| ✅ Vorteile                                       | ⚠️ Nachteile                                                        |
| ------------------------------------------------ | ------------------------------------------------------------------- |
| Subjekt und Beobachter sind unabhängig           | In großen Systemen entstehen Aktualisierungskaskaden                |
| Neue Beobachter können leicht hinzugefügt werden | Beim Entfernen müssen Beobachter manuell abgemeldet werden          |
| Flexibel und erweiterbar                         | Alle Beobachter erhalten Updates, auch wenn sie nicht relevant sind |
| Daten bleiben im System konsistent               | Potenziell hohe Update-Frequenz bei vielen Beobachtern              |


![Observer Pattern](/Entwurfsmuster/Observer.png)

---

### 🧠 Kompetenzcheck (richtige Aussagen)

* ✅ a) Entwurfsmuster = Lösung für wiederkehrendes Problem
* ✅ b) Anti-Pattern = negatives Gegenstück eines Entwurfsmusters
* ✅ c) Es gibt Erzeugungs-, Struktur- und Verhaltensmuster
* ❌ d) Bridge = Strukturmuster (nicht Erzeugungsmuster)
* ✅ e) Singleton = sorgt für nur eine Instanz
* ❌ f) Factory = Erzeugungsmuster (nicht Strukturmuster)
* ✅ g) Factory kapselt Objekterzeugung
* ✅ h) Adapter verbindet inkompatible Schnittstellen
* ✅ i) Adapter kann durch Mehrfachvererbung realisiert werden
* ✅ j) Observer = Verhaltensmuster
* ✅ k) Observer kann im MVC-Pattern verwendet werden

---

### 📘 Fazit

Das **Observer Pattern** ist essenziell für **reaktive, entkoppelte Systeme**.
Es stellt sicher, dass **Änderungen automatisch propagiert** werden, wie etwa bei **Model-View-Updates** im MVC-Design.

</section>

