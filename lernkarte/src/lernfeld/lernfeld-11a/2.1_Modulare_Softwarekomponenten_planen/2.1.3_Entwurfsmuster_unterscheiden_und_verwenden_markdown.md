# 2.1.3 Entwurfsmuster unterscheiden und verwenden

<section style="font-family: 'Segoe UI', Roboto, sans-serif; color: #000; background: #fff; padding: 24px; line-height: 1.6; margin: auto; border-radius: 12px; box-shadow: 0 0 10px rgba(0,0,0,0.1);">

## ğŸ§© 2.1.3 Entwurfsmuster â€“ Grundlagen und Anwendung

### ğŸ’¡ Definition

Ein **Entwurfsmuster (Design Pattern)** ist eine **bewÃ¤hrte, flexible LÃ¶sung** fÃ¼r ein **wiederkehrendes Problem** in der Softwareentwicklung.
Sie dienen der Strukturierung, Wiederverwendbarkeit und Wartbarkeit von Code.

---

### ğŸ—ï¸ Kategorien von Entwurfsmustern

| Kategorie                         | Beschreibung                                              | Beispiele                   |
| --------------------------------- | --------------------------------------------------------- | --------------------------- |
| **Erzeugungsmuster (Creational)** | Regeln die **Erstellung von Objekten**                    | Factory, Singleton, Builder |
| **Strukturmuster (Structural)**   | Beschreiben **Beziehungen und Zusammenspiel** von Klassen | Adapter, Bridge, Facade     |
| **Verhaltensmuster (Behavioral)** | Bestimmen **Interaktionen und Verantwortlichkeiten**      | Observer, Command, Iterator |

---

### âš™ï¸ Factory Pattern (Erzeugungsmuster)

**Zweck:**
Trennung von Objekterstellung und Nutzung. Der Client kennt nicht die konkreten Klassen, sondern arbeitet Ã¼ber ein **Interface**.

**Aufbau:**

* Eine **Factory-Klasse** erzeugt Objekte bestimmter Typen.
* Der **Client** fordert Ã¼ber die Factory ein Objekt an.
* Neue Typen kÃ¶nnen leicht ergÃ¤nzt werden, ohne den Client-Code zu Ã¤ndern.

**Vorteil:** Hohe FlexibilitÃ¤t und Erweiterbarkeit bei der Objekterzeugung.

```text
Client â†’ Factory â†’ Interface â†’ konkrete Klassen (Type 1, Type 2)
```
![Factory](/Entwurfsmuster/Adapter.png)
---

### ğŸ” Singleton Pattern (Erzeugungsmuster)

**Problem:**
Es soll **nur eine einzige Instanz** einer Klasse existieren (z. B. Log-Datei, Druckerzugriff).

**LÃ¶sung:**

* Der **Konstruktor ist privat**, um Mehrfacherzeugung zu verhindern.
* Eine **statische Methode `getInstance()`** liefert das einzige Objekt zurÃ¼ck.
* Die Klasse verwaltet ihre eigene Instanz intern.

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}
```

---

### âš–ï¸ Vor- und Nachteile des Singleton-Patterns

| âœ… Vorteile                            | âš ï¸ Nachteile                      |
| ------------------------------------- | --------------------------------- |
| Einfach umsetzbar                     | Gefahr â€quasi-globalerâ€œ Variablen |
| Spart Ressourcen (Lazy Instantiation) | Erschwerte Testbarkeit            |
| Vermeidung globaler Variablen         | Problematisch bei Multithreading  |
| Kann durch Vererbung angepasst werden | Schwierige Ressourcenfreigabe     |


[Singleton](/Entwurfsmuster/Singleton.png)
---

### ğŸš« Anti-Pattern

**Definition:** Schlechte oder schÃ¤dliche Entwurfspraktiken.
Beispiele:

* **Gottobjekt:** Klasse mit zu vielen Verantwortlichkeiten â†’ Verletzung der Modularisierung
* **Zwiebel:** Neue Funktionen werden unstrukturiert â€um alten Codeâ€œ gebaut
* **Copy & Paste:** Ãœbernahme von Code ohne VerstÃ¤ndnis oder Anpassung

Selbst **Design Patterns** wie Singleton kÃ¶nnen bei Ãœbernutzung zu **Anti-Pattern** werden (eingeschrÃ¤nkte Skalierbarkeit, Testprobleme).

---

### ğŸ“˜ Fazit

Entwurfsmuster sind **Werkzeuge fÃ¼r wiederkehrende Entwurfsprobleme**, keine starren Regeln.
Sie fÃ¶rdern **sauberen, wartbaren und flexiblen Code**, sollten jedoch **gezielt und bedarfsgerecht** eingesetzt werden.

</section>

<section style="font-family:'Segoe UI', Roboto, sans-serif; color:#000; background:#fff; padding:24px; line-height:1.6; max-width:900px; margin:auto; border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1);">

## ğŸ­ Factory Pattern (Erzeugungsmuster)

### ğŸ’¡ Ziel

Das **Factory Pattern** trennt die **Erzeugung von Objekten** von deren **Verwendung**.
Der Client arbeitet nur mit **abstrakten Klassen oder Interfaces** und kennt die konkreten Implementierungen nicht.

---

### âš™ï¸ Problemstellung

* Zur **Entwicklungszeit** ist nicht bekannt, welche konkreten Klassen spÃ¤ter instanziiert werden mÃ¼ssen.
* Der **Erstellungsprozess von Objekten** soll **einfach erweiterbar** und **unabhÃ¤ngig von der Nutzung** sein.
* Typische Einsatzgebiete: Frameworks, Bibliotheken, Plugin-Systeme.

---

### ğŸ§  LÃ¶sungskonzept

Das Factory Pattern nutzt **abstrakte Erzeuger- und Produktklassen**:

1. **Abstrakter Erzeuger (Creator/Factory)**

   * Definiert die Methode `erzeugeProdukt()`, die ein abstraktes Produkt zurÃ¼ckgibt.
   * Wird in Unterklassen **Ã¼berschrieben**.

2. **Konkreter Erzeuger**

   * Implementiert die Methode und erzeugt ein **konkretes Produktobjekt**.
   * EnthÃ¤lt einen **Verweis auf das konkrete Produkt**.

3. **Abstraktes Produkt**

   * Definiert das gemeinsame Interface fÃ¼r alle Produktvarianten.

4. **Konkretes Produkt**

   * Implementiert das Interface des abstrakten Produkts.

![Factory](/Entwurfsmuster/Factory.png)

---

### ğŸ” AufbauÃ¼bersicht

```text
Client
  â†“
Erzeuger (abstract)
  â†³ + erzeugeProdukt(): Produkt
      â†“
KonkreterErzeuger â†’ KonkretesProdukt
Produkt (abstract)
```

â¡ï¸ **Im Client werden nur abstrakte Klassen verwendet.**
â¡ï¸ **Der konkrete Erzeuger entscheidet, welches Produkt erzeugt wird.**

---

### ğŸ§© Beispiel (Java)

```java
abstract class Produkt {
    abstract void anzeigen();
}

class KonkretesProdukt extends Produkt {
    void anzeigen() { System.out.println("Konkretes Produkt erstellt."); }
}

abstract class Erzeuger {
    abstract Produkt erzeugeProdukt();
}

class KonkreterErzeuger extends Erzeuger {
    Produkt erzeugeProdukt() { return new KonkretesProdukt(); }
}
```

---

### âš–ï¸ Vor- und Nachteile

| âœ… Vorteile                                               | âš ï¸ Nachteile                                                   |
| -------------------------------------------------------- | -------------------------------------------------------------- |
| Gute Erweiterbarkeit fÃ¼r neue Produkttypen               | Enge Koppelung zwischen Erzeuger und Produkt                   |
| Erzeugung ist von der Verwendung getrennt                | FÃ¼r jedes neue Produkt muss ein neuer Erzeuger erstellt werden |
| Nutzung unbekannter Objekte zur Entwicklungszeit mÃ¶glich | Hohe Klassenanzahl bei vielen Produkten                        |

---

### ğŸ“˜ Fazit

Das **Factory Pattern** ist ein zentrales Erzeugungsmuster der objektorientierten Programmierung.
Es ermÃ¶glicht **flexible, erweiterbare Softwarearchitekturen**, besonders in Frameworks, bei denen konkrete Objekte erst **zur Laufzeit** bestimmt werden.

</section>

--- 
<section style="font-family:'Segoe UI', Roboto, sans-serif; color:#000; background:#fff; padding:24px; line-height:1.6; max-width:900px; margin:auto; border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1);">

## ğŸ”Œ Adapter Pattern (Strukturmuster)

### ğŸ’¡ Ziel

Das **Adapter Pattern** verbindet **inkompatible Schnittstellen**, sodass bestehende Klassen weiterhin genutzt werden kÃ¶nnen, ohne deren Code zu verÃ¤ndern.
Es dient der **Anpassung und Wiederverwendung** von Softwarekomponenten.

---

### âš™ï¸ Problemstellung

* Eine **bestehende Klasse** bietet die gewÃ¼nschte FunktionalitÃ¤t, jedoch **nicht die benÃ¶tigte Schnittstelle**.
* Der Code dieser Klasse (z. B. aus einer Drittanbieter-Bibliothek) **kann oder soll nicht geÃ¤ndert werden**.
* Der **Klient** benÃ¶tigt eine **andere Schnittstelle**, um mit der Klasse zu kommunizieren.

ğŸ“˜ **Beispiel:**
Ein **USB-zu-Ethernet-Adapter** verbindet zwei inkompatible Schnittstellen â€“ dieses Prinzip Ã¼bertrÃ¤gt das Pattern auf Software.

---

### ğŸ§  LÃ¶sungskonzept

Der **Adapter** Ã¼bersetzt die Schnittstelle der adaptierten Klasse in die Schnittstelle, die der Klient erwartet.
Es gibt **zwei Varianten**:

#### 1ï¸âƒ£ Umsetzung mittels **Delegation (Objektadapter)**

* Der Adapter **enthÃ¤lt eine Instanz** der adaptierten Klasse.
* Er **delegiert** Aufrufe der Client-Schnittstelle an die passende Methode der adaptierten Klasse.
* **Flexibel**, da auch Unterklassen adaptiert werden kÃ¶nnen.

```java
class Adapter implements Schnittstelle {
    private AdaptierteKlasse adaptiert;
    public void operation() {
        adaptiert.spezifischeOperation();
    }
}
```

#### 2ï¸âƒ£ Umsetzung mittels **Vererbung (Klassenadapter)**

* Der Adapter **erbt** von der adaptierten Klasse **und** implementiert die benÃ¶tigte Schnittstelle.
* **Effizient**, aber weniger flexibel (funktioniert nicht fÃ¼r Unterklassen).

```java
class Adapter extends AdaptierteKlasse implements Schnittstelle {
    public void operation() {
        spezifischeOperation();
    }
}
```

---

### ğŸ” StrukturÃ¼bersicht

| Objektadapter (Delegation)             | Klassenadapter (Vererbung)              |
| -------------------------------------- | --------------------------------------- |
| Adapter **enthÃ¤lt** adaptiertes Objekt | Adapter **erbt** von adaptiertem Objekt |
| Basiert auf **Komposition**            | Basiert auf **Vererbung**               |
| Kann **mehrere Klassen** anpassen      | Kann **nur eine Klasse** anpassen       |
| **HÃ¶here FlexibilitÃ¤t**                | **Schnellere Implementierung**          |

---

### âš–ï¸ Vor- und Nachteile

| âœ… Vorteile                                    | âš ï¸ Nachteile                                    |
| --------------------------------------------- | ----------------------------------------------- |
| ErhÃ¶ht Wiederverwendbarkeit von Komponenten   | ZusÃ¤tzliche Zwischenklasse                      |
| Objektadapter kann auch Unterklassen anpassen | Klassenadapter kann keine Unterklassen anpassen |
| Gute Trennung von Schnittstellen              | Kann zu komplexeren Strukturen fÃ¼hren           |

![Adapter](/Entwurfsmuster/Adapter.png)
---

### ğŸ“˜ Fazit

Das **Adapter Pattern** ist ein wichtiges **Strukturmuster**, das hilft, alte oder fremde Klassen in neue Systeme zu integrieren.
Es bietet eine **BrÃ¼cke zwischen inkompatiblen Schnittstellen** â€“ analog zu realen Hardware-Adaptern.

</section>

---

<section style="font-family:'Segoe UI', Roboto, sans-serif; color:#000; background:#fff; padding:24px; line-height:1.6; max-width:900px; margin:auto; border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1);">

## ğŸ‘ï¸ Observer Pattern (Beobachter-Muster)

### ğŸ’¡ Ziel

Das **Observer Pattern** (Beobachter-Muster) dient der **Trennung von Datenhaltung und Darstellung**.
Es sorgt dafÃ¼r, dass **alle abhÃ¤ngigen Komponenten automatisch Ã¼ber Ã„nderungen informiert werden**, ohne dass sie eng gekoppelt sind.

---

### âš™ï¸ Problemstellung

* Ã„nderungen an einem Objekt sollen **automatisch an abhÃ¤ngige Objekte weitergegeben** werden.
* Die **Informationsquelle (Subjekt)** und die **EmpfÃ¤nger (Beobachter)** sollen **unabhÃ¤ngig voneinander** bleiben.
* Beispiel:
  Im **MVC-Pattern** (Model-View-Controller) muss die **View** informiert werden, wenn sich die Daten im **Model** Ã¤ndern.

---

### ğŸ§  LÃ¶sungskonzept

Das Observer Pattern gehÃ¶rt zu den **Verhaltensmustern (Behavioral Design Patterns)**.
Ein **Subjekt** verwaltet eine Liste von **Beobachtern** und informiert diese bei Ã„nderungen seines Zustands.

#### ğŸ”© Hauptbestandteile

| Klasse                    | Aufgabe                                                                                                  |
| ------------------------- | -------------------------------------------------------------------------------------------------------- |
| **Subjekt**               | Verwaltung der Beobachter (Anmelden, Abmelden, Benachrichtigen)                                          |
| **Beobachter (Observer)** | Definiert eine Methode `aktualisieren()`, die aufgerufen wird, wenn sich der Zustand des Subjekts Ã¤ndert |
| **Konkretes Subjekt**     | EnthÃ¤lt den aktuellen Zustand und ruft `benachrichtigen()` bei Ã„nderungen auf                            |
| **Konkreter Beobachter**  | Reagiert auf Ã„nderungen und aktualisiert seine Daten                                                     |

---

### ğŸ” Varianten der Umsetzung

| Variante                     | Beschreibung                                                   |
| ---------------------------- | -------------------------------------------------------------- |
| **Push Notification**        | Subjekt benachrichtigt Beobachter, diese holen selbst Daten ab |
| **Push-Update Notification** | Subjekt sendet Ã„nderungen direkt an Beobachter                 |
| **Pull Notification**        | Beobachter fragen selbststÃ¤ndig den Zustand beim Subjekt ab    |

---

### ğŸ§© UML-Ablauf (vereinfacht)

```text
Subjekt
 â”œâ”€ + anmelden(Beobachter)
 â”œâ”€ + abmelden(Beobachter)
 â””â”€ + benachrichtigen()
        â†“
Beobachter
 â””â”€ + aktualisieren()
```

â¡ï¸ Bei ZustandsÃ¤nderung ruft das Subjekt alle registrierten Beobachter auf.
â¡ï¸ Beobachter holen sich neue Daten oder werden direkt informiert.

---

### ğŸ§® Beispiel (Java)

```java
interface Beobachter {
    void aktualisieren();
}

class Subjekt {
    private List<Beobachter> beobachterListe = new ArrayList<>();
    void anmelden(Beobachter b) { beobachterListe.add(b); }
    void abmelden(Beobachter b) { beobachterListe.remove(b); }
    void benachrichtigen() { for (Beobachter b : beobachterListe) b.aktualisieren(); }
}
```

---

### âš–ï¸ Vor- und Nachteile des Observer Patterns

| âœ… Vorteile                                       | âš ï¸ Nachteile                                                        |
| ------------------------------------------------ | ------------------------------------------------------------------- |
| Subjekt und Beobachter sind unabhÃ¤ngig           | In groÃŸen Systemen entstehen Aktualisierungskaskaden                |
| Neue Beobachter kÃ¶nnen leicht hinzugefÃ¼gt werden | Beim Entfernen mÃ¼ssen Beobachter manuell abgemeldet werden          |
| Flexibel und erweiterbar                         | Alle Beobachter erhalten Updates, auch wenn sie nicht relevant sind |
| Daten bleiben im System konsistent               | Potenziell hohe Update-Frequenz bei vielen Beobachtern              |


![Observer Pattern](/Entwurfsmuster/Observer.png)

---

### ğŸ§  Kompetenzcheck (richtige Aussagen)

* âœ… a) Entwurfsmuster = LÃ¶sung fÃ¼r wiederkehrendes Problem
* âœ… b) Anti-Pattern = negatives GegenstÃ¼ck eines Entwurfsmusters
* âœ… c) Es gibt Erzeugungs-, Struktur- und Verhaltensmuster
* âŒ d) Bridge = Strukturmuster (nicht Erzeugungsmuster)
* âœ… e) Singleton = sorgt fÃ¼r nur eine Instanz
* âŒ f) Factory = Erzeugungsmuster (nicht Strukturmuster)
* âœ… g) Factory kapselt Objekterzeugung
* âœ… h) Adapter verbindet inkompatible Schnittstellen
* âœ… i) Adapter kann durch Mehrfachvererbung realisiert werden
* âœ… j) Observer = Verhaltensmuster
* âœ… k) Observer kann im MVC-Pattern verwendet werden

---

### ğŸ“˜ Fazit

Das **Observer Pattern** ist essenziell fÃ¼r **reaktive, entkoppelte Systeme**.
Es stellt sicher, dass **Ã„nderungen automatisch propagiert** werden, wie etwa bei **Model-View-Updates** im MVC-Design.

</section>

