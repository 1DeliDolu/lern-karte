# 2.1.3 Entwurfsmuster unterscheiden und verwenden [Seite: 126]

**Entwurfsmuster** sind wiederverwendbare Lösungsansätze für häufig auftretende Entwurfsprobleme. Sie unterscheiden sich von **Algorithmen** durch ihren Charakter als flexibler „Bauplan“, der an verschiedene Anforderungen anpassbar bleibt. Man unterscheidet drei Kategorien: **Erzeugungsmuster** (Objekterzeugung), **Strukturmuster** (Beziehungen/Zusammenwirken von Klassen/Objekten) und **Verhaltensmuster** (Interaktionen/Verantwortlichkeiten). Entwurfsmuster erhöhen Wartbarkeit und Flexibilität, sollten aber gezielt und problemgetrieben eingesetzt werden. 

**Einsatzhinweise & Anti-Pattern**
Entwurfsmuster nur bei realen Problemen verwenden; Übernutzung (z. B. **Singleton**) kann schaden. **Anti-Pattern** sind bekannte, aber ungünstige/gefährliche Lösungswege (z. B. **Gottobjekt**, „**Zwiebel**“, „**Copy and Paste**“). Vor- und Nachteile einzelner Muster stets abwägen. 

## Beispielmuster (ausgewählte)

### Singleton (Erzeugungsmuster)

* **Problem:** Es darf genau **eine Instanz** einer Klasse existieren (z. B. Zugriff auf zentrale Hardware-Ressourcen; teure Initialisierung).
* **Lösung/Prinzip:** Klasse kontrolliert ihre Instanziierung selbst; **privater Konstruktor**, Zugriff über **statische** Methode (z. B. `getInstance()`); hält genau eine **statische Referenz**.
* **Vorteile:** Einfach umsetzbar; vermeidet „globale Variablen“; Instanz entsteht erst bei Bedarf; per **Vererbung** spezifizierbar.
* **Nachteile:** Gefahr „quasi-globaler“ Zustände; **Thread-Safety** beachten; erschwert **Tests**; unklare **Ressourcenfreigabe**; kann Skalierbarkeit hemmen (→ in extremen Fällen Anti-Pattern).



<div style="display:flex;justify-content:center">
    <img src="/lernfeld11a/2_1_3/singleton.png" alt="Abbildung" style="max-width:100%;height:auto;display:block;margin:0;" />
</div>


### Factory (Erzeugungsmuster)

* **Problem:** Zu erstellende **Produkte** sind zur Entwicklungszeit nicht bekannt; **Erstellungsprozess** soll erweiterbar und von der **Verwendung** getrennt sein (typisch in **Frameworks/Bibliotheken**).
* **Lösung/Prinzip:** **Erzeuger** (abstrakt) kapselt Objekterzeugung und delegiert an **konkrete Erzeuger**; Klient arbeitet gegen **Abstraktionen** (Produkt/Erzeuger) und ist von Implementierungen entkoppelt.
* **Vorteile:** Gute **Erweiterbarkeit** (neue Produkte); **Entkopplung** von Erzeugung und Nutzung; auch Nutzung noch nicht implementierter Produkte.
* **Nachteile:** **Enge Koppelung** konkreter Erzeuger an konkrete Produkte; für jedes neue Produkt u. U. **neue Klassen** nötig → Klasseninflation.



<div style="display:flex;justify-content:center">
    <img src="/lernfeld11a/2_1_3/factory.png" alt="Abbildung" style="max-width:100%;height:auto;display:block;margin:0;" />
</div>

### Adapter (Strukturmuster)

* **Problem:** Wiederverwendbare Komponente hat eine **inkompatible Schnittstelle**; Quellcode der Komponente ist **unveränderlich** (z. B. Drittanbieter).
* **Lösung/Prinzip:** **Adapter** übersetzt zwischen **Klient-Schnittstelle** und **adaptierter Klasse**. Zwei Varianten:

  * **Objektadapter** (via **Delegation**): passt auch **Unterklassen** an.
  * **Klassenadapter** (via **Vererbung**): optimal an Zielklasse, aber nicht für Unterklassenanpassung geeignet.
* **Vorteile:** Erhöht **Wiederverwendbarkeit**; flexible Integration inkompatibler Komponenten.
* **Nachteile:** Zusätzliche **Zwischenklasse**; Klassenadapter weniger flexibel bzgl. Unterklassen.


<div style="display:flex;justify-content:center">
    <img src="/lernfeld11a/2_1_3/adapter.png" alt="Abbildung" style="max-width:100%;height:auto;display:block;margin:0;" />
</div>

### Observer (Verhaltensmuster)

* **Problem:** **Erzeugung/Verwaltung von Daten** soll von **Verarbeitung/Darstellung** getrennt sein; bei Änderungen sollen abhängige Komponenten **automatisch informiert** werden (z. B. **MVC**: Model → View).
* **Lösung/Prinzip:** **Subjekt** bietet **An-/Abmeldung** für **Beobachter**; bei Änderungen **benachrichtigt** das Subjekt alle Beobachter → diese **aktualisieren** ihren Zustand. Varianten:

  * **Push Notification:** Beobachter werden benachrichtigt, holen Änderungen selbst.
  * **Push-Update Notification:** Änderungen werden **mitgeliefert**.
  * **Pull Notification:** Beobachter **fragen** Zustand aktiv ab.
* **Vorteile:** **Entkopplung** von Subjekt/Beobachter; **flexibel** erweiterbar; **konsistente** Daten im System.
* **Nachteile:** Gefahr von **Aktualisierungskaskaden**; sauberes **Abmelden** nötig; ggf. **irrelevante Updates** bei Beobachtern.


<div style="display:flex;justify-content:center">
    <img src="/lernfeld11a/2_1_3/observer.png" alt="Abbildung" style="max-width:100%;height:auto;display:block;margin:0;" />
</div>

## Merksätze

* Wähle ein **Entwurfsmuster** nur, wenn sein **Problem-Fit** gegeben ist.
* Arbeite gegen **Abstraktionen** (Interfaces/Basisklassen), nicht gegen konkrete Implementierungen.
* Prüfe **Nebenwirkungen** (z. B. Testbarkeit, Parallelität, Ressourcenfreigabe). 

---

## [Nächstes Thema](./2.1.4_Clean-Code-Prinzipien_praesentieren_markdown.md)