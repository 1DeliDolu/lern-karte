# 2.1.4 Clean-Code-Prinzipien präsentieren [Seite: 131]

**Clean Code** zielt darauf ab, Quellcode so zu schreiben, dass er **lesbar**, **verständlich** und **wartbar** ist. Ein Großteil der Entwicklungszeit fließt in Änderungen an bestehendem Code; funktionierender Code ist nicht automatisch gut verständlich. Deshalb soll „sauberer“ Code möglichst von Anfang an entstehen, anstatt sich auf spätes **Refactoring** zu verlassen. 

## Ziele und Motivation

* **Problemfokus:** Änderungen an unübersichtlichem Code verursachen Fehler, Zeit- und Kostenaufwand; Projekte können im schlimmsten Fall nicht mehr weiterentwickelt werden.
* **Zielbild:** Klarer, strukturierter Code reduziert Risiken und erleichtert Pflege und Erweiterung. 

## Refactoring (Begriff)

**Refactoring** ist die **Strukturverbesserung** von Quellcode **ohne** Änderung der Funktionalität. Es steigert **Lesbarkeit**, **Verständlichkeit**, **Wartbarkeit** und **Erweiterbarkeit**. Dennoch wird es in der Praxis oft aufgeschoben—ein weiterer Grund, Clean Code direkt umzusetzen. 

## Grundprinzipien (Auswahl mit Kurzdefinition)

* **KISS** (*Keep It Simple and Stupid*): Lösungen so **einfach** wie möglich halten; unnötige **Komplexität** vermeiden. 
* **DRY** (*Don’t Repeat Yourself*): **Redundanzen** vermeiden; wiederverwendbare Funktionen/Klassen auslagern. 
* **Komposition statt Vererbung (FCoI)**: **Komposition** bevorzugen, um **Entkopplung** und **Flexibilität** zu erhöhen. 
* **IHP** (*Information Hiding Principle*): Interna von **Modulen kapseln**; Zugriff nur über **Schnittstellen**. 
* **LoD** (*Law of Demeter*): **Geringe Kopplung**; Klassen kommunizieren nur mit **nahen** Partnern. 
* **TDA** (*Tell, Don’t Ask*): Daten + Verhalten **zusammenfassen**; Objekten **sagen**, was zu tun ist, statt Daten herauszuziehen. 
* **YAGNI** (*You Ain’t Gonna Need It*): Nur **benötigte** Funktionalität implementieren, keine Vorab-Features. 

## SOLID-Prinzipien (Empfehlung)

Als **grundlegende** Leitplanken werden die **SOLID**-Prinzipien (SRP, OCP, LSP, **ISP**, **DIP**) hervorgehoben. Sie sind besonders wirksam, auch wenn die vollständige Umsetzung aller Prinzipien nicht immer möglich ist. 

## Code-Konventionen & Hinweise

* **Source-Code-Konventionen** (z. B. **Namensregeln**, **Kommentare**, **White Spaces**) erhöhen **Lesbarkeit** und **Konsistenz**—gerade in größeren Projekten. 
* **Vorsicht vor Optimierungen:** Nur optimieren, wenn **wirklich nötig**; sonst kosten sie überproportional Zeit. 
* **Entwurf ↔ Implementation:** Die Implementation soll den **Entwurf** **widerspiegeln**; getrennt geplante Module nicht „nebenbei“ zusammenziehen. 

## Praxistipps (aus dem Abschnitt)

* **Code schrittweise verbessern:** „Verlasse den Code **besser**, als du ihn vorgefunden hast.“
* **Konsequent formatieren:** **Einrückungen**, **kurze Zeilen**, **einheitliche** Umsetzung ähnlicher Dinge.
* **Sprechende Namen:** **Beschreibende**, **eindeutige** Bezeichner; **Magic Numbers** durch **Konstanten** ersetzen.
* **Kleine Funktionen:** **Wenige Parameter**, fokussierte Aufgaben.
* **Kommentare sparsam:** Code soll **für sich sprechen**; nur **notwendige** Kommentare.
* **Variablen nahe der Nutzung deklarieren**; **Programmierzkonventionen** einhalten. 

## Umsetzung in der Praxis

Clean-Code-Prinzipien sind leicht zu verstehen, aber **schwer dauerhaft** umzusetzen (Disziplin/Erfahrung nötig). **Kontinuierliche Auseinandersetzung** mit den Prinzipien führt zu Routine. Es existiert u. a. die **Clean-Code-Developer-Initiative** als Orientierungsangebot.
