# 2.1.4 Clean-Code-Prinzipien präsentieren

<section style="font-family:'Segoe UI', Roboto, sans-serif; color:#000; background:#fff; padding:24px; line-height:1.6;  margin:auto; border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1);">

## 🧹 2.1.4 Clean-Code-Prinzipien

### 💡 Grundidee

**Clean Code** beschreibt Richtlinien für **lesbaren, wartbaren und verständlichen Quellcode**.
Ziel ist es, Software so zu gestalten, dass sie **einfach erweiterbar** bleibt und **Fehler sowie Wartungskosten reduziert** werden.
Ein sauberer Code ist **nicht nur funktional**, sondern auch **nachvollziehbar und klar strukturiert**.


![Clean-Code-Prinzipien](/Clean-Code-Prinzipien/Clean-Code-Prinzipien.png)

---

### 🧱 Refactoring

Unter **Refactoring** versteht man das **Verbessern der Code-Struktur**, ohne die Funktionalität zu verändern.
Ziele:

* Bessere **Lesbarkeit** und **Wartbarkeit**
* Vermeidung von **Redundanzen**
* Vereinfachung komplexer Strukturen

---

### ⚙️ Zentrale Clean-Code-Prinzipien

| Kürzel    | Prinzip                              | Beschreibung                                                                      |
| :-------- | :----------------------------------- | :-------------------------------------------------------------------------------- |
| **KISS**  | *Keep It Simple, Stupid*             | Code so einfach wie möglich halten – keine unnötige Komplexität.                  |
| **DRY**   | *Don’t Repeat Yourself*              | Vermeide Code-Duplikate; zentrale Logik in Funktionen/Klassen auslagern.          |
| **FCoI**  | *Favor Composition over Inheritance* | Bevorzugung von Komposition gegenüber Vererbung – fördert Flexibilität.           |
| **SLA**   | *Single Level of Abstraction*        | Gleiche Abstraktionsebenen innerhalb einer Funktion – klare Struktur.             |
| **SRP**   | *Single Responsibility Principle*    | Jede Klasse/Funktion hat genau **eine Aufgabe**.                                  |
| **SoC**   | *Separation of Concerns*             | Trennung der Verantwortlichkeiten in einzelne Module.                             |
| **DIP**   | *Dependency Inversion Principle*     | Abhängigkeiten nur zu **Abstraktionen** (Interfaces), nicht zu konkreten Klassen. |
| **ISP**   | *Interface Segregation Principle*    | Interfaces sollen klein und spezifisch sein.                                      |
| **OCP**   | *Open Closed Principle*              | Klassen sind offen für Erweiterungen, aber geschlossen für Änderungen.            |
| **LSP**   | *Liskov Substitution Principle*      | Subtypen müssen sich wie ihre Basistypen verhalten.                               |
| **IHP**   | *Information Hiding Principle*       | Innere Implementierung verbergen – Zugriff über Schnittstellen.                   |
| **YAGNI** | *You Ain’t Gonna Need It*            | Nur Funktionen implementieren, die wirklich benötigt werden.                      |

---

### 🧩 SOLID-Prinzipien

Die fünf wichtigsten Clean-Code-Prinzipien:

| Kürzel | Prinzip                     | Ziel                                |
| :----- | :-------------------------- | :---------------------------------- |
| **S**  | SRP – Single Responsibility | Eine Klasse = eine Aufgabe          |
| **O**  | OCP – Open/Closed           | Erweiterbar, aber nicht veränderbar |
| **L**  | LSP – Liskov Substitution   | Subtypen können Basistypen ersetzen |
| **I**  | ISP – Interface Segregation | Spezifische, kleine Interfaces      |
| **D**  | DIP – Dependency Inversion  | Abhängigkeit zu Abstraktionen       |

➡️ Diese fünf Prinzipien gelten als **Grundpfeiler von „Clean Code“**.

---

### 🧠 Praxistipps für sauberen Code

* ✅ **Code verbessern**, wenn man ihn verändert („Leave the code cleaner than you found it“).
* ✅ **Programmierkonventionen** einhalten (z. B. Namensregeln, Einrückungen).
* ✅ **Kurze, prägnante Funktionen** mit wenigen Parametern.
* ✅ **Sprechende Namen** für Variablen, Klassen und Methoden verwenden.
* ✅ **„Magic Numbers“ vermeiden** – stattdessen Konstanten nutzen.
* ✅ **Kommentare nur bei Notwendigkeit**; der Code sollte sich selbst erklären.
* ✅ **Variablen nahe ihrer Nutzung deklarieren.**
* ✅ **Ähnliche Aufgaben auf gleiche Weise implementieren.**

---

### 💬 Clean-Code-Developer-Initiative

Die Bewegung [clean-code-developer.de](https://clean-code-developer.de) fördert **Professionalität und Disziplin** beim Programmieren.
Ziel: Einheitliche Regeln für **nachhaltige Softwarequalität** und **kontinuierliche Verbesserung**.

---

### 🧠 Kompetenzcheck (richtige Aussagen)

✅ a) Clean Code zielt auf lesbaren und wartbaren Quellcode ab.<br>
✅ b) Refactoring = Strukturverbesserung ohne Funktionsänderung.<br>
✅ c) KISS fordert einfache, klare Lösungen.<br>
❌ d) Kein Ziel ist maximale Funktionalität in einem Modul.<br>
❌ e) Fokus liegt auf Lesbarkeit, nicht nur auf Effizienz.<br>
✅ f) Komposition wird der Vererbung vorgezogen.<br>
✅ g) SOLID = SRP, OCP, LSP, ISP, DIP.<br>
❌ h) „Magic Numbers“ verschlechtern die Wartbarkeit.<br>
✅ i) Sprechende Namen erhöhen Verständlichkeit.<br>
✅ j) Code sollte so klar sein, dass wenige Kommentare nötig sind.<br>

---

### 📘 Fazit

**Clean Code** bedeutet nicht nur funktionierende Software, sondern **nachhaltig verständlichen Code**.
Er vereint **Disziplin, Einfachheit und Struktur** – Grundlage für professionelle Softwareentwicklung und Teamarbeit.

</section>
