# 2.1 Modulare Softwarekomponenten planen [Seite: 110]

**Ziel & Kontext.** Moderne Software muss wachsende funktionale und nicht-funktionale Anforderungen erfüllen. Ein zentraler Lösungsansatz ist die **Modularisierung**: Systeme werden in unabhängige **Module** mit klaren **Schnittstellen** zerlegt, geplant (u. a. mit **UML**) und nach **Clean-Code-Prinzipien** umgesetzt. Sequenz- und Zustandsdiagramme werden als zusätzliche Beschreibungsmittel eingeführt. 

## 2.1.1 Prinzip der Modularisierung

**Kernaussagen.**

* **Modul** = funktional geschlossene Einheit mit eindeutig spezifizierten **Schnittstellen**; intern beliebig aufgebaut, nach außen gekapselt.
* Modularisierungsebenen: **Methode/Funktion** → **Klasse** → **Softwarekomponente**.
* **Vorteile:** höhere Verständlichkeit, **Wiederverwendbarkeit**, Austausch-/Änderbarkeit, parallele Entwicklung über definierte Schnittstellen.
* **Designregeln:** **Modulgeschlossenheit**, hohe **Modulbindung** (Cohesion), geringe **Modulkopplung**, **Minimalität der Schnittstelle**, **Testbarkeit** (isolierte **Modultests**).
* Beispielhafte Domänenzerlegung (Projekt „Yachthafen Resort“): u. a. **Gebäudemanagement**, **Gastronomie**, **Event-**/**Personal-**/**Yachthafen-management**. 

## 2.1.2 Softwarekomponenten mit UML beschreiben

**Zweck.** UML dient der präzisen, tool-unabhängigen Planung von Struktur und Verhalten. Wiederholt/vertieft: **Anwendungsfall-**, **Klassen-**, **Aktivitätsdiagramm**; neu: **Zustands-** und **Sequenzdiagramm**. Grundlage ist die Komponente **Liegeplatzverwaltung**. 

**Anwendungsfalldiagramm.**

* Elemente: **Systemgrenze**, **Akteur**, **Anwendungsfall**, **Assoziation**, **«include»**, **«extend»**, **Generalisierung**.
* Beispiel: Mieter kann Liegeplatz **mieten/kündigen**, **an-/abmelden**; Mitarbeitende **sperren/freigeben/zuweisen**; System prüft **Verfügbarkeit**; alle sehen **Belegung**. 

**Klassendiagramm.**

* Elemente: **Klasse** (Attribute/Methoden, **Sichtbarkeit**), **Assoziation**, **Aggregation**, **Komposition**, **Vererbung**, **Multiplizität**.
* Beispielklassen: **Yacht**, **Mieter**, **Liegeplatz**; Aggregationen zu **Liegeplatz**; Methoden aus den Anwendungsfällen abgeleitet. 

**Aktivitätsdiagramm.**

* Elemente: **Start/Ende**, **Aktion**, **Kanten**, **Verzweigung/Zusammenführung**, **Aufspaltung/Synchronisation**, **Partitionen**.
* Beispielprozess **„Liegeplatz mieten“** (Kunde/Programm): Liste anzeigen → Verfügbarkeit prüfen → Daten erfassen/speichern → Bestätigung + E-Mail (parallel). 

**Zustandsdiagramm.**

* Elemente: **(Anfangs/End)zustand**, **Zustand**, **Transition** *(Trigger [Guard] / Action)*, **Verzweigung**.
* Beispiel **Liegeplatz-Status**: **verfügbar → vermietet/belegt/gesperrt**, Übergänge durch **mieten/kündigen/sperren/freigeben/an-/abmelden**. 

**Sequenzdiagramm.**

* Elemente: **Interaktionsrahmen**, **Objekte**, **Lebenslinien**, **Aktivierungen**, **synchrone/asynchrone Nachrichten**, **Antworten**, **Selbstdelegation**, **Objekterzeugung/-löschung**, **Fragmente** (**alt**, **loop**, **opt**, **par**).
* Beispiel **„Yacht im Hafen anmelden“**: Mieter → App → DB (Prüfen); *alt*: Daten **OK** → Objekt anlegen + Bestätigung, sonst Ablehnung. 

## 2.1.3 Entwurfsmuster (Design Patterns)

**Einordnung & Nutzen.**

* Kategorien: **Erzeugungsmuster** (z. B. **Factory**, **Singleton**, **Builder**), **Strukturmuster** (z. B. **Adapter**, **Bridge**, **Facade**), **Verhaltensmuster** (z. B. **Observer**, **Command**, **Iterator**).
* **Anti-Pattern** meiden (z. B. **Gottobjekt**, **Zwiebel**, **Copy & Paste**). Muster gezielt einsetzen, Over-Engineering vermeiden (v. a. **Singleton**). 

**Muster im Überblick.**

* **Singleton**: genau **eine Instanz** über **private**r Konstruktor + statische **getInstance**; + einfach, vermeidet globale Variablen; − Testbarkeit, Skalierung/Threads, mögliche „quasi-globale“ Zustände.
* **Factory**: trennt **Erzeugung** von **Nutzung**; Client spricht **Abstraktionen** an; + erweiterbar, entkoppelt; − mehr Klassen, Kopplung konkreter Erzeuger↔Produkt.
* **Adapter**: vermittelt zwischen **inkompatiblen Schnittstellen** (Objekt- oder Klassenadapter); + Wiederverwendung; − zusätzliche Zwischenklasse/Vererbungsgrenzen.
* **Observer**: **Subjekt** benachrichtigt **Beobachter** (Push, Push-Update, Pull); + flexible Entkopplung; − Aktualisierungskaskaden, Abmeldedisziplin nötig. 

## 2.1.4 Clean-Code-Prinzipien

**Motivation & Begriff.**

* Ziel: **Lesbarkeit**, **Verständlichkeit**, **Wartbarkeit**. **Refactoring** = Strukturverbesserung ohne Verhaltensänderung. 

**Zentrale Prinzipien.**

* **KISS**, **DRY**, **FCoI** (*Komposition vor Vererbung*), **SLA**, **SRP**, **SoC**, **DIP**, **ISP**, **OCP**, **LSP**, **IHP**, **LoD**, **TDA**, **YAGNI**.
* **SOLID** (SRP, OCP, LSP, ISP, DIP) als Kernempfehlung. 

**Konventionen & Praxistipps.**

* Einheitliche **Source-Code-Konventionen**, sprechende **Bezeichner**, **Einrückungen**, kurze **Funktionen/Zeilen**, wenige **Parameter**, keine **Magic Numbers** (Konstanten), sparsame **Kommentare**, vorsichtige **Optimierungen**, **Implementierung** spiegelt **Entwurf**. Guideline: „**Verlasse den Code besser, als du ihn vorgefunden hast.**“ 

## Ergebnisnutzen für die Komponentenplanung

Kombiniert angewandt liefern Modularisierung, UML, Entwurfsmuster und Clean-Code eine **wartbare**, **erweiterbare** und **testbare** Architektur mit klaren **Schnittstellen** und guter **Team-Skalierbarkeit**—entscheidend für nachhaltige Softwarequalität. 

---

**Hinweis zur Terminologie (fett markiert):** *Modul, Schnittstelle, Modularisierung, Modulbindung/-kopplung, Aggregation/Komposition, Vererbung, Anwendungsfall, Zustand/Transition, Interaktionsfragment, Factory/Singleton/Adapter/Observer, Refactoring, SOLID, DRY, KISS* usw.
